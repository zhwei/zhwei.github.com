[{"content":"引子 推荐虚拟组网工具前先说一下个人网络环境。\n在前司工作时，由于一直是远程工作，几乎随时都要联通公司内网，前司的 VPN 用的深信服的 SSL VPN。Mac 端的客户端非常难用，几乎隔几小时就要断一次，于是写了个 AppleScript 自动重连脚本续了一段时间。但有个问题，手机上很难访问公司内网，且不说其手机客户端有多难用，深信服 VPN 限定了一个用户只能有一个设备在线，想在手机上测试时非常痛苦。\n另外，一直使用 Surge 作为代理客户端，增强模式真的是非常强大，除了强大的规则、代理功能之外，日常用来抓包也非常方便。\n于是有了个想法，能不能把公司的内网转发也交给 Surge 处理呢？\n说干就干，在公有云申请了一台 Windows Server 主机作为 Gateway，之所以用 Windows 是因为深信服 VPN 的 Windows 客户端相对更稳定一些，然后在 WinServer 运行 VPN 客户端，又写了一个 AutoIT 脚本守护这个客户端，一旦断开自动重连。最后，通过 SS 暴露给 Surge 使用，非常完美！从此以后彻底摆脱了深信服的 VPN 客户端，手机端也可以非常顺滑的访问公司内网资源。\n有了带公网 IP 的 Gateway 后，我又盯上了家里的 NAS ！这玩意怎样在保证安全的前提下载公网使用呢？\n虚拟组网 本地组网相比大家都非常熟悉，一堆设备挂在交换机或者路由器下面，就可以组成一个简单的局域网，各设备直接可通过局域网 IP 访问。\n与本地组网不同的是，虚拟组网设备之间没有通过网线连接，甚至不在一个机房、国家甚至地区。但通过 P2P 或者中转节点，实现了局域网的效果。\n下面列一下从开始使用到目前为止遇到的组网工具机器优缺点。\nZeroTier  https://www.zerotier.com\n 我目前用的工具，放在最开始并不意味着它是最好的，但它是最适合我的个人场景的。\n优点\n P2P 通信 支持自建 moon 节点，用于服务发现（已自建） 当无法建立 P2P 通信时，流量也会通过 moon 节点转发  国内运营商会限制 UDP 流量，甚至分配假的公网 IP，导致无法建立 P2P 链接 所以还是用自己的更放心 :)   有 Windows、NAS GUI 客户端，配对简单 有在线 Central 管理功能，强大又方便（相对于下面方案需要自己手写配置配置文件）  在线路由管理很强大    缺点\n 商业公司（各有利弊吧） 免费套餐有节点数目限制  Nebula  https://github.com/slackhq/nebula\n Slack 出品的开源项目\n优点\n 开源 P2P 通信 命令行生成配置文件，相对简单 完全自建 Lighthouse 节点，安全信得过  缺点\n 人工管理证书，人工分发，相对麻烦 无法统一管理授信客户端，只能增加黑名单  证书泄露了会很危险，需要更新所有节点配置文件   虽然已经 1.x 版本，但个人感觉仍处于早期阶段 只支持 P2P 通信  无法通过 Lighthouse 节点转发流量，遇到国内奇葩的网络环境时就废了    Tinc  https://www.tinc-vpn.org\n 老牌 VPN ，看官网样式就能 GET 到了。我在另一个生产环境用到了 Tinc，虽然 ZeroTier 也不错，但毕竟是个商业服务，不如开源项目用起来放心 + 便宜。\n优点\n 开源 P2P main 节点支持流量转发 支持在 main 节点统一管理受信节点  缺点\n 人工管理证书，人工分发，相对麻烦  其他 tailscale，https://tailscale.com\n 也是个商业服务，没有使用过，暂不评价  WireGuard，https://www.wireguard.com\n 也是老牌子了，tailscale 基于它开发的 之前在生产项目中也尝试过，但它对内核有要求，需要重启机器，弃用了 没有深度使用，无法评价优缺点  内网穿透代理 下面两个工具和前面提到的虚拟组网并不是一类工具，但在特定场景用起来会非常方便。例如，在本地开发时需要接受第三方服务的 callback 时，可以使用下面工具临时暴露本地服务到公网。\n ngrok，https://ngrok.com frp，https://github.com/fatedier/frp  ","date":"2021-02-05T00:00:00Z","permalink":"https://zhw.in/post/virtual-networking/","title":"虚拟组网工具推荐"},{"content":"引子 好久没写博客了，有点手痒，想了想就写一篇关于播客的吧。 从 18 年开始有了听播客的习惯，最早关注的播客是《津津乐道》。再早之前也曾听过几个节目，比如最近开始复更的《Teahour》早期关于工程师的一期，当时对播客这个概念很陌生，播客对我也没有多少吸引力。 再到后来一次开车赶路途中，心血来潮听了津津乐道有一期关于 ‘伪科学’ 的节目，突然感觉：咦，这玩意有点意思。\n工具控 Podcast iOS 用户知道播客这个东西后，一般都会使用 Podcast App 听播客，但后来感觉这玩意体验很不好，其中最令人讨厌的地方是操作层级太深了，比如，我在发现新的播客后，会习惯性地翻一遍主播的历史节目，每次都要在多个 tab 里切好几遍才能找到历史节目列表，很令人抓狂。\nOvercast 后来从津津乐道的节目介绍中知道了原来还有泛用性播客客户端这东西，基于 rss 订阅，这玩意儿对程序员来说熟悉的很呀。搜罗了一下找到了 Overcast 这个 App，功能简单，页面粗犷，但它有两个特性我非常喜欢：\n Smart Speed，自动压缩没有声音的时长 Voice Boost，放大主播声音  尤其是后者，早期很多播客的制作品质并不高，主播声音经常被背景音或其他杂音盖过。 用了一年后，甚至订阅了 Premium 支持它，最终还是放弃了，因为真的是太粗犷了，播放列表和订阅列表放在同一个页面，订阅多了之后，只能靠搜索，每次使用都影响心情。\n然后开始寻找其他替代 App\n 又尝试了一下 Podcast App，然后果断放弃 Castro，Overcast 免费提供的两个特性，在 Castro 里是需要付费的，感觉吃相不好看，放弃 最终试用了 Pocket Casts，很不错  Pocket Casts 使用 Overcast 之前也发现了这个 App，但在国区貌似无法安装，当时不太想折腾也就跳过了，再次尝试发现真香：\n 首页订阅列表，每行四个播客 icon，查找播客很方便 Filter 支持更多筛选条件，左右滑动加到播放列表顶部/底部，每次操作都令人愉悦 Overcast 提供的两个功能也都在 公司产品，迭代频率较高 统计功能，满足自己小小的虚荣心  果断订阅 Plus 支持了，截止目前，在 Pocket Casts 收听总时长已经接近八天了。\n播客推荐 顺序大概按喜爱程度+订阅时间。\n津津乐道 内容覆盖 TMT、旅游、健康、美食、装修、新消费等领域，主播和嘉宾们都是有丰富业内经验的牛人，风格轻松愉快，讲解由浅到深，偶尔也有些硬核内容，十分推荐。\n疯投圈 新消费领域的两位投资人，为大家讲解生意。\n一派 Podcast 经常会在 Apple 苹果发布会当晚深夜录制简评节目，祝努力的人都有好运气！ 访谈节目嘉宾都很有意思，比如最近禅修节目中的 XMind 创始人。\nTeahour、牛油果烤面包、内核恐慌、捕蛇者说 IT 从业者适合听的节目，部分节目超级硬核。 最近印象较深的是内核恐慌的《吟诗的光猫》。 Teahour 更新频率较低，作为古早的播客，能年更也可以作为遗迹来瞻仰了。\n其他 其他还有非常多优质播客，比如黑水公园、侃爷茶馆、ggtalk、生活漫游指南、声东击西等等，几乎每期都会听，之后可能会单拉出来写两句推荐吧。\n","date":"2021-01-11T00:00:00Z","image":"https://zhw.in/post/podcast/Xnip2021-01-12_20-13-04_hud23b41a33a32b215b19ef445300fe136_877907_120x120_fill_q75_box_smart1.jpg","permalink":"https://zhw.in/post/podcast/","title":"关于播客"},{"content":"起因 团队使用 Jenkins CI 来对 Pull Request 进行上线前的检查，例如：编码风格、静态分析、测试等。\n最近遇到了测试时的并发问题，由于 Jenkins 需要在 PR 更新时重新检查，每完整测试一次需要 10 到 15 分钟，同时有很多开发者提交 PR 时，就会导致长时间无意义的等待，有此希望能提高 Jenkins 的并发测试能力。\n选择方案 先介绍下项目测试时依赖的环境：\n- PHP - Redis - MySQL - ElasticSearch  多个 PR 测试进程之间，ES、Redis 是可以共享的，但 MySQL 不可以，其中考虑的方案是考虑能否通过改变项目中的数据库名称从而共享同一台 MySQL Server ，但实际调试中发现除去 ORM 能够简单变更数据库外，还是有很多场景中的数据库名称是写死在代码里面的，所以这条方案宣告放弃。\n如标题所说，我们的 Jenkins 是运行在 docker 中的，那测试是不是也可以在 docker 中运行呢，所有依赖环境、软件包，全部通过 docker 打包整理，最终 Jenkins 在发起测试时需要调用的是一个 docker 命令，那么问题来了，怎样让 Jenkins 调用 docker ？想到的有以下两个思路：\n  Jenkins 中完整安装 docker ，关注点：\n 需要重新 build jenkins image，调试会很麻烦 性能会不会有问题？docker 中运行了一个 docker ，然后在这个 docker 里运行了四个实例 网络会不会有问题？172 这个网段会不会混乱（还是调试问题）    Jenkins 中调用宿主机的 docker ，关注点：\n 是否可行？ 优点：不需要重新 build jenkins image ，开箱即用，扩展 slave 会很方便     后来发现前者的思路就是 GitLab CI 的测试方式，不过当时为了调试方便，以及减轻后续 jenkins 镜像升级的痛苦，选择了后者，也在网上确认到了确实有人这么实践过，并且 work 。\n 使用宿主机 docker 运行测试 Jenkins 调用宿主机 docker 的方法其实很简单：\n  jenkins 中需要安装 docker client\n 推荐 Docker CE ，二进制文件，下载下来就能用\n   映射宿主机的 /var/run/docker.sock 到 jenkins\n 这样我们上面安装的 docker client 可以直接通过此 socket 文件与宿主机的 docker daemon 通信\n   之后可以测试下能否正常通信：./docker ps，打印出的应该是宿主机中正在运行的容器。\n 由于 Jenkins 容器的运行用户为 jenkins ，而挂载的 volume 默认用户是 root ，所以需要在容器运行后修改一下 docker.sock 文件的权限，这里我的容器是使用 docker compose 启动的，所以使用了命令：docker-compose exec --user=0 master chmod o+rw /var/run/docker.sock 来赋予 jenkins 读写 sock 文件的权限\n 这样 jenkins 中的 docker 就能够与宿主机的 docker daemon 通信了。\n测试中的坑  volume 映射   由于 jenkins 运行 docker 时实际是在宿主机运行的，所以如果你需要将代码库位置映射进测试容器，那映射的真实路径应该是宿主机的路径，如下：\n 宿主机的 JENKINS_HOME ：/home/docker/jenkins/volume/master Jenkins 中的 HOME ：/var/jenkins_home/ Jenkins 运行测试时的映射命令：  ... -v /home/docker/jenkins/volume/master/workspaces/ProjectName:/ProjectName\n     环境变量  如上 volume 映射，也要再设置一遍\n... -e \u0026quot;MYSQL_HOST=${MYSQL_HOST}\u0026quot; 参考链接  Using Docker-in-Docker for your CI or testing environment? Think twice. Docker-in-Docker  ","date":"2017-12-04T00:00:00Z","permalink":"https://zhw.in/post/docker-jenkins-run-tests-in-docker/","title":"Docker Jenkins Run Tests in Docker"},{"content":"GitHub：ThinkDevelopers/PHPConChina, PDF file link ","date":"2017-06-21T00:00:00Z","permalink":"https://zhw.in/post/phpcon-china-laravel-lego-%E5%88%86%E4%BA%AB%E7%9A%84-slide/","title":"PHPCon China Laravel Lego 分享的 Slide"},{"content":"被问到了HTTP常见的几个方法，也有些迷惑的地方，整理如下。\nGET GET是http的默认请求方式， 一般用来获取数据， 传输的数据经过url编码后放在路径?之后， 多个键值对通过\u0026amp;连接， 另外get的传输长度一般不推荐超过255个字节。\nGET方法一般被视为安全方法， 因为它仅用来获取数据而不会对服务器有其他改动。\n 安全方法\n像HEAD、GET、OPTIONS 和 TRACE这几种http方法是被认为是“安全的”， 这意味着它们只会进行获取数据而不会修改服务器的状态， 换句话说，它们不会产生负面影响， 当然除了常见的无害操作，比如记录日志、创建缓存或者创建其他统计信息。\n正相反， 像POST、PUT、DELETE 和 PATCH 等方法是有可能产生副作用。网络爬虫等一般不会使用这些方式(笔者注:搜索引擎的暗网抓取可能会使用这些方法)。\n尽管GET方法是一般被视为“安全的”，但如果在实际使用中没有做任何设置，比如可以无限制的抓取等情况， 也会导致一些不可预料的问题，比如web缓存或者搜索引擎问题。\n POST POST一般用来上传文件或者提交一个完整的web表单。\n这是Chrome中查看到的POST内容\n实际数据是这样的\nuser=554101\u0026amp;user_code=eNWyXdrrTpC6hoSvzPHBYKLljGkcDw79QsWtNeMu\u0026amp;attachment=0\u0026amp;code_brush=\u0026amp;code_snippet=\u0026amp;msg=test  浏览器中提交表单时，这里与get类似，每个键值对都是通过\u0026amp;分割, 其他非字母数字会进行url转码。\n为什么一些请求会使用POST提交数据?\n GET请求数据都可以在URL中看到 GET提交的数据都会有长度限制 一般规范，POST用来修改数据，GET用来获取数据 GET请求请提交的数据放置在HTTP请求协议头中，而POST提交的数据则放在实体数据中  其他请求方式 HEAD 获取某个URI响应头信息，基本与GET相同但是不返回响应主体。\nPUT 通过提供的URI获取到特定的内容主体，如果存在则修改内容，如果不存在则创建。\nDELETE 通过URI删除指定内容\nTRACE 返回接受到的请求，用来查看数据经过中间服务器时发生了哪些变动\nOPTIONS 返回给定URL支持的所有HTTP方法\nCONNECT 要求使用SSL和TLS进行TCP通信\nPATCH 请求修改局部数据\n参考链接  http://en.wikipedia.org/wiki/POST_(HTTP) http://en.wikipedia.org/wiki/GET_(HTTP)  ","date":"2014-06-16T00:00:00Z","permalink":"https://zhw.in/post/http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B3%A8%E8%A7%A3/","title":"HTTP请求方式注解"},{"content":"AGILE WEB DEVELOPMENT WITH DJANGO\n","date":"2014-06-13T00:00:00Z","permalink":"https://zhw.in/post/web%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/","title":"Web敏捷开发"},{"content":"from django.forms.models import model_to_dict, fields_for_model class UserDetailsForm(ModelForm): def __init__(self, instance=None, *args, **kwargs): _fields = (\u0026#39;first_name\u0026#39;, \u0026#39;last_name\u0026#39;, \u0026#39;email\u0026#39;,) _initial = kwargs.pop(\u0026#39;initial\u0026#39;) # pop出initial参数 _initial = model_to_dict(instance.user, _fields) if instance is not None else {} super(UserDetailsForm, self).__init__(initial=_initial, instance=instance, *args, **kwargs) self.fields.update(fields_for_model(User, _fields)) class Meta: model = UserDetails exclude = (\u0026#39;user\u0026#39;,) def save(self, *args, **kwargs): u = self.instance.user u.first_name = self.cleaned_data[\u0026#39;first_name\u0026#39;] u.last_name = self.cleaned_data[\u0026#39;last_name\u0026#39;] u.email = self.cleaned_data[\u0026#39;email\u0026#39;] u.save() profile = super(UserDetailsForm, self).save(*args,**kwargs) return profile 取自 http://stackoverflow.com/questions/15889794/creating-one-django-form-to-save-two-models\n不过原文中的代码会出现 __init__() got multiple values for keyword argument 报错。\n是因为kwargs中已经包含initial参数，而在调用父类的初始化方法时候将initial独立传递, 这样就造成了传递了两次 initial参数，所以会报出上面的错误。只要将 initial从kwargs中pop出来就可以了。\n","date":"2014-02-19T00:00:00Z","permalink":"https://zhw.in/post/django%E4%BB%8E%E4%B8%80%E4%B8%AAform%E4%BF%9D%E5%AD%98%E5%88%B0%E4%B8%A4%E4%B8%AAmodel/","title":"django从一个form保存到两个model"},{"content":"Gotit 近段时间的改进和以后一段时间内的更新计划，挖坑的时间到了，准备跳票。\n改进   使用requests替代urllib requests的确是HTTP library human， 自动处理文字编码、灵活的cookie操作，的确赏心悦目！并且它的cookie支持pickle，因此可以直接将每次的请求缓存到redis，相对于以前缓存整个对象到内存中的全局字典，不得不说更稳定灵活了好多！\n  重写正方查询的类与缓存机制 原来的正方类是与自己写的缓存紧密耦合的，旧的缓存机制使用内存全局字典作为存放地点，创建缓存与缓存过期判断都是由多个线程判断，并且某些线程在特定条件下还会创建更多子线程，到了最后虽然能正常工作但不得不说成了像shi一样的代码。现在所有缓存都放在redis中，缓存的过期时间完全由redis控制，只在用户每次查询操作时重置缓存时间就可以了。\n  完善异常处理 一直没有想到正方教务系统竟然有那么多的报错提醒，由于其多数请求异常都是弹窗提醒，所以可以通过特定的正则表达式匹配出多数的弹窗提醒，在每次页面请求后都会检测是否有弹窗警告，主要是登录时候的报错，新生没有更改初始密码是不能进行查询的。\n  彻底放弃了bs3分支 bs3分支就是上面说的时候大量线程进行提前缓存，当时还写了一篇博客，后来发现，出现的问题远大于解决的问题，并且大量线程在正方系统发生宕机或者其他异常时候会一直阻塞，也一直找不到合适的解决方案，痛苦了好久后决定放弃该分支，继续升级维护2.0-stable分支。但是已经将bs3中的Bootstrap3界面迁移到了2.0分支。\n  待做  优化缓存 有些时候用户查询到的内容是没有发生变化的，打算将用户查询到的内容缓存到redis中，并且某些时候（例如过年前后）正方教务系统可能会直接停止，在这种情况下可以通过使用长期缓存。  另外可以在用户查询单个内容时，为用户将其他内容缓存。（例如当张三在查询当前学期成绩时，返回成绩后继续将他的课表、绩点、考试时间等内容缓存，如果他继续查询其他内容，响应速度将会大量提高，不再受正方、网络延时的影响。\n 优化移动端页面  移动端的浏览量与PC端的浏览量相差无几， 移动端需要优化的主要是查询结果页面的表格，前段时间迁移bootstrap3后使用了bs的响应式表格，但是在uc浏览器上无法使用，所以又添加了一个表格调整的按钮切换回旧的样式。这也是一个急需解决的问题。\n 网站后台 话说到现在为止gotit是没有网站后台的，所有的配置都是写在配置文件中，好吧，话说主要是想偷懒。现在后台已经在开发之中，包括每个页面的公告、网站公告、捐献者等内容，当然还有网站的各种日志，也不希望每次都要远程到服务器上才能看到到底发生了什么。  还有一个目的就是积累用户啦，主要推广方法还是靠下一个内容了。\n 成绩更新提醒 成绩提醒，就是在成绩更新后及时通知给相应的用户，这里只要保留cookie就行了，不过由于神一样的正方教务系统在大量请求下极其脆弱，每一次宕机cookie就失效了，再由于中文验证码的存在，还没有完善的解决方案，所以算是一个超级Beta内容了，将来只会对捐献者开放这项功能。  ","date":"2014-02-18T00:00:00Z","permalink":"https://zhw.in/post/gotit%E6%94%B9%E8%BF%9B%E4%B8%8E%E5%BE%85%E5%81%9A/","title":"Gotit改进与待做"},{"content":"   \n \n","date":"2014-02-09T00:00:00Z","permalink":"https://zhw.in/post/%E5%AE%B6%E9%87%8C%E7%9A%84%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%9B%AA/","title":"家里的第一场雪"},{"content":"Supervisor是一个C/S系统，用来监控和控制多个服务进程，只限于UNIX-like操作系统。\n官方文档 http://supervisord.org/\n安装 setuptools\npip install supervisor # or easy_install supervisor 初始使用 创建配置文件 需要以root身份执行\necho_supervisord_conf \u0026gt; /etc/supervisord.conf  调整配置文件  增加web管理界面  取消配置文件中的下列行，并按需配置用户名密码\n[inet_http_server] port=*:9001 username=your_username ; (default is no username (open server)) password=your_password ; (default is no password (open server)) 添加服务 配置文件详解\n[supervisorctl] serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL for a unix socket ;serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket ;username=chris ; should be same as http_username if set ;password=123 ; should be same as http_password if set ;prompt=mysupervisor ; cmd line prompt (default \u0026#34;supervisor\u0026#34;) ;history_file=~/.sc_history ; use readline history if available 添加单个进程 ; 管理单个进程的配置，可创建多个，下面是所有可能的配置选项 ;[program:theprogramname] ;command=/bin/cat ; 启动进程的命令 使用相对路径，可以加参数 ;process_name=%(program_name)s ; 进程名称 表达式 (默认 %(program_name)s) ;numprocs=1 ; 进程数目 (def 1) ;directory=/tmp ; 执行命令所在的目录 (def no cwd) ;umask=022 ; 进程默认权限 (default None) ;priority=999 ; 进程启动相对优先权 (default 999) ;autostart=true ; 跟随supervisor启动时启动 (default: true) ;autorestart=unexpected ; 计划启动 (default: unexpected) ;startsecs=1 ; 延时启动 (def. 1) ;startretries=3 ; 最多连续启动失败 (default 3) ;exitcodes=0,2 ; 进程结束代码 (default 0,2) ;stopsignal=QUIT ; signal used to kill process (default TERM) ;stopwaitsecs=10 ; 最长结束等待时间，否则使用 SIGKILL (default 10) ;stopasgroup=false ; 是否想UNIX进程组发送结束信号 (default false) ;killasgroup=false ; SIGKILL UNIX 进程组 (def false) ;user=chrism ; 设置启动此程序的用户 ;redirect_stderr=true ; 重定向程序的标准错误到标准输出 (default false) ;stdout_logfile=/a/path ; 标准输出的日志路径, NONE for none; default AUTO ;stdout_logfile_maxbytes=1MB ; 日志文件最大值，否则循环写入 (default 50MB) ;stdout_logfile_backups=10 ; 标准输出日志备份数目 (default 10) ;stdout_capture_maxbytes=1MB ; number of bytes in \u0026#39;capturemode\u0026#39; (default 0) ;stdout_events_enabled=false ; emit events on stdout writes (default false) ;stderr_logfile=/a/path ; 标准错误输出日志路径, NONE for none; default AUTO ;stderr_logfile_maxbytes=1MB ; 日志文件最大值，否则循环写入 (default 50MB) ;stderr_logfile_backups=10 ; 标准错误日志备份数目 (default 10) ;stderr_capture_maxbytes=1MB ; number of bytes in \u0026#39;capturemode\u0026#39; (default 0) ;stderr_events_enabled=false ; emit events on stderr writes (default false) ;environment=A=\u0026#34;1\u0026#34;,B=\u0026#34;2\u0026#34; ; 进程附加环境 (def no adds) ;serverurl=AUTO ; override serverurl computation (childutils) 添加事件监听器 ; The below sample eventlistener section shows all possible ; eventlistener subsection values, create one or more \u0026#39;real\u0026#39; ; eventlistener: sections to be able to handle event notifications ; sent by supervisor. ; 下面是事件监听器的可选配置, supervisor能够处理事件通知. ; ; ** 译者注： 和上面相同的解释没有翻译 ** ;[eventlistener:theeventlistenername] ;command=/bin/eventlistener ; the program (relative uses PATH, can take args) ;process_name=%(program_name)s ; process_name expr (default %(program_name)s) ;numprocs=1 ; number of processes copies to start (def 1) ;events=EVENT ; event notif. types to subscribe to (req\u0026#39;d) ;buffer_size=10 ; 事件缓冲队列的大小 (default 10) ;directory=/tmp ; directory to cwd to before exec (def no cwd) ;umask=022 ; umask for process (default None) ;priority=-1 ; the relative start priority (default -1) ;autostart=true ; start at supervisord start (default: true) ;autorestart=unexpected ; whether/when to restart (default: unexpected) ;startsecs=1 ; number of secs prog must stay running (def. 1) ;startretries=3 ; max # of serial start failures (default 3) ;exitcodes=0,2 ; \u0026#39;expected\u0026#39; exit codes for process (default 0,2) ;stopsignal=QUIT ; signal used to kill process (default TERM) ;stopwaitsecs=10 ; max num secs to wait b4 SIGKILL (default 10) ;stopasgroup=false ; send stop signal to the UNIX process group (default false) ;killasgroup=false ; SIGKILL the UNIX process group (def false) ;user=chrism ; setuid to this UNIX account to run the program ;redirect_stderr=true ; redirect proc stderr to stdout (default false) ;stdout_logfile=/a/path ; stdout log path, NONE for none; default AUTO ;stdout_logfile_maxbytes=1MB ; max # logfile bytes b4 rotation (default 50MB) ;stdout_logfile_backups=10 ; # of stdout logfile backups (default 10) ;stdout_events_enabled=false ; emit events on stdout writes (default false) ;stderr_logfile=/a/path ; stderr log path, NONE for none; default AUTO ;stderr_logfile_maxbytes=1MB ; max # logfile bytes b4 rotation (default 50MB) ;stderr_logfile_backups ; # of stderr logfile backups (default 10) ;stderr_events_enabled=false ; emit events on stderr writes (default false) ;environment=A=\u0026#34;1\u0026#34;,B=\u0026#34;2\u0026#34; ; process environment additions ;serverurl=AUTO ; override serverurl computation (childutils) 添加进程组 ; The below sample group section shows all possible group values, ; create one or more \u0026#39;real\u0026#39; group: sections to create \u0026#34;heterogeneous\u0026#34; ; process groups. ; 下面是进程组的可选配置，可以创建一个或多个进程组。 ;[group:thegroupname] ;programs=progname1,progname2 ; 这里的进程名是上文 [program:theprogramname] 定义的theprogramname ;priority=999 ; the relative start priority (default 999) 命令行工具 supervisorctl 查看所有命令\n$ supervisorctl help default commands (type help ): ===================================== add clear fg open quit remove restart start stop update avail exit maintail pid reload reread shutdown status tail version 命令功能 作者:\t飞龙 http://feilong.me/2011/03/monitor-processes-with-supervisord supervisord，初始启动Supervisord，启动、管理配置中设置的进程。 supervisorctl stop programxxx，停止某一个进程(programxxx)，programxxx为[program:chatdemon]里配置的值，这个示例就是chatdemon。 supervisorctl start programxxx，启动某个进程 supervisorctl restart programxxx，重启某个进程 supervisorctl stop groupworker: ，重启所有属于名为groupworker这个分组的进程(start,restart同理) supervisorctl stop all，停止全部进程，注：start、restart、stop都不会载入最新的配置文件。 supervisorctl reload，载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程。 supervisorctl update，根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启。 注意：显示用stop停止掉的进程，用reload或者update都不会自动重启。 ","date":"2013-12-14T00:00:00Z","permalink":"https://zhw.in/post/supervisor%E7%AC%94%E8%AE%B0/","title":"Supervisor笔记"},{"content":"介绍 LVM Logical Volume Manager\nLVM是Linux环境下对磁盘分区进行管理的一种机制，LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。\n能解决哪些问题  在线通过增加或减少物理卷组改变逻辑卷组的大小 在小型系统上，比如个人电脑，不必在安装系统的时候费脑筋估算分区的大小，lvm上以后可以按需求轻易调整分区的大小。 能够对逻辑分区实现一致性备份 可以在多个物理卷或者整个硬盘上创建单个分区，有点像RAID 0, 但更像JBOD, 允许动态调整卷的大小。  创建LVM 如果要在/dev/sda3, /dev/sda4, /dev/sda5上创建lvm\n创建物理卷\npvcreate /dev/sda{3..5}  创建为卷组\nvgcreate test0 /dev/sda{3..5}  在卷组test0上创建10G的逻辑卷 lv_0\nlvcreate -L 10G -n lv_0 test0  创建文件系统并挂载\nmkfs.ext4 /dev/test0/lv_0  扩容 需求： 将物理卷/dev/sda6 加入lvm并扩大为20G\n创建物理卷\npvcreate /dev/sda6  添加到卷组test0\nvgextend test0 /dev/sda6  扩展逻辑卷, 扩展到20G\nlvextend -L 20G /dev/test0/lv_0  使增加的容量生效\nresize2fs /dev/test0/lv_0  搞定\n减容 需求： 将逻辑卷减小成10G\n先将该分区卸载\numount /data  检查逻辑卷\ne2fsck -f /dev/test0/lv_0  调整文件系统大小\nresize2fs /dev/test0/lv_0 10G  对逻辑卷进行调整\nlvreduce /dev/test0/lv_0 10G  删除lvm lvremove /dev/test0/lv_0 vgremove /dev/test0 pvremove /dev/sda{3..5}  #更多用法\n$ sudo lvm lvm\u0026gt;; help Available lvm commands: Use \u0026#39;lvm help \u0026#39; for more information dumpconfig Dump active configuration formats List available metadata formats help Display help for commands lvchange Change the attributes of logical volume(s) lvconvert Change logical volume layout lvcreate Create a logical volume lvdisplay Display information about a logical volume lvextend Add space to a logical volume lvmchange With the device mapper, this is obsolete and does nothing. lvmdiskscan List devices that may be used as physical volumes lvmsadc Collect activity data lvmsar Create activity report lvreduce Reduce the size of a logical volume lvremove Remove logical volume(s) from the system lvrename Rename a logical volume lvresize Resize a logical volume lvs Display information about logical volumes lvscan List all logical volumes in all volume groups pvchange Change attributes of physical volume(s) pvresize Resize physical volume(s) pvck Check the consistency of physical volume(s) pvcreate Initialize physical volume(s) for use by LVM pvdata Display the on-disk metadata for physical volume(s) pvdisplay Display various attributes of physical volume(s) pvmove Move extents from one physical volume to another pvremove Remove LVM label(s) from physical volume(s) pvs Display information about physical volumes pvscan List all physical volumes segtypes List available segment types vgcfgbackup Backup volume group configuration(s) vgcfgrestore Restore volume group configuration vgchange Change volume group attributes vgck Check the consistency of volume group(s) vgconvert Change volume group metadata format vgcreate Create a volume group vgdisplay Display volume group information vgexport Unregister volume group(s) from the system vgextend Add physical volumes to a volume group vgimport Register exported volume group with system vgmerge Merge volume groups vgmknodes Create the special files for volume group devices in /dev vgreduce Remove physical volume(s) from a volume group vgremove Remove volume group(s) vgrename Rename a volume group vgs Display information about volume groups vgscan Search for all volume groups vgsplit Move physical volumes into a new or existing volume group version Display software and driver version information ","date":"2013-12-13T00:00:00Z","permalink":"https://zhw.in/post/lvm%E7%AC%94%E8%AE%B0/","title":"lvm笔记"},{"content":" 开始前   帽子 \n s   t \n","date":"2013-12-08T00:00:00Z","permalink":"https://zhw.in/post/pyconchina%E4%B8%8A%E6%B5%B7%E5%9C%BA%E7%8E%B0%E5%9C%BA/","title":"PyConChina上海场现场"},{"content":"由来 最近在写一个服务器监控平台，python开发，前端标准bootstrap，后端Bottle, 数据库mongodb，要写服务器监控肯定少不了客户端了，客户端主要用到了XMLRPCServer, 服务端与客户端通过xml通信，这个在python的标准库里，还是可以信赖的，并且支持http验证，此处不赘言，以后再讲。linux上的客户端很好搞，因为linux自带python解释器，不管版本如何，使用起来还是很好改的， 最头疼的是window下的客户端，以前很少在win下做开发，python环境也是随意搭了一下，正使用的时候还是各种DT。。。\n花了一段时间写了一个win下的python程序，不过依赖很多，包括pywin32、wmi，并且python的安装还需要改注册表，作为一个监控，如果还需要在服务器上安装python环境等东西有点得不偿失了。找到了pyinstaller和py2exe，能够将python程序打包成可执行的exe文件，复制到其他机器上可以直接执行，下面进入正题！\n各种环境安装  安装pywin32、wmi弹框   Python version 2.7 required, which was not found in the registry 在注册表中找不到python，使用下面的一个脚本放在c盘根目录执行下就可以, 见Link\n程序 # SmallestService.py # # A sample demonstrating the smallest possible service written in Python. import win32serviceutil import win32service import win32event class SmallestPythonService(win32serviceutil.ServiceFramework): _svc_name_ = \u0026#34;SmallestPythonService\u0026#34; _svc_display_name_ = \u0026#34;The smallest possible Python Service\u0026#34; def __init__(self, args): win32serviceutil.ServiceFramework.__init__(self, args) # Create an event which we will use to wait on. # The \u0026#34;service stop\u0026#34; request will set this event. self.hWaitStop = win32event.CreateEvent(None, 0, 0, None) def SvcStop(self): # Before we do anything, tell the SCM we are starting the stop process. self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING) # And set my event. win32event.SetEvent(self.hWaitStop) def SvcDoRun(self): # We do nothing other than wait to be stopped! win32event.WaitForSingleObject(self.hWaitStop, win32event.INFINITE) if __name__==\u0026#39;__main__\u0026#39;: win32serviceutil.HandleCommandLine(SmallestPythonService) 不过这样写好之后发现，直接运行脚本的确可以正常添加服务，添加的服务也可以正常操作，但是使用pyinstaller打包后的程序并不能正常执行。在pyinstaller的邮件列表找到了一个解决方案。 见 Link\n具体细节不明了，需要改动的就是SvcDoRun方法和SvcStop两个方法。\n因为RPCServer会一直阻塞线程，这里创建了一个子线程创建RPCServer，使用一个循环条件来控制线程的终结Link，这样不会导致window服务无法停止的问题。 需要在SvcStop方法最后加上所执行的程序的终结方法就可以。\n","date":"2013-11-10T00:00:00Z","permalink":"https://zhw.in/post/pyinstaller%E6%89%93%E5%8C%85python%E5%86%99%E7%9A%84windows%E6%9C%8D%E5%8A%A1-%E8%AE%B0%E5%BD%95/","title":"Pyinstaller打包Python写的windows服务-记录"},{"content":" 用python写的windows服务，支持pyinstaller打包。  # Usage: # service.exe install # service.exe start # service.exe stop # service.exe remove # you can see output of this program running python site-packages win32libwin32traceutil import win32service import win32serviceutil import win32event import win32evtlogutil import win32traceutil import servicemanager import winerror import time import sys import os class aservice(win32serviceutil.ServiceFramework): _svc_name_ = \u0026#34;aservice\u0026#34; _svc_display_name_ = \u0026#34;aservice - It Does nothing\u0026#34; _svc_deps_ = [\u0026#34;EventLog\u0026#34;] def __init__(self,args): win32serviceutil.ServiceFramework.__init__(self,args) self.hWaitStop=win32event.CreateEvent(None, 0, 0, None) self.isAlive=True def SvcStop(self): # tell Service Manager we are trying to stop (required) self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING) # write a message in the SM (optional) # import servicemanager # servicemanager.LogInfoMsg(\u0026#34;aservice - Recieved stop signal\u0026#34;) # set the event to call win32event.SetEvent(self.hWaitStop) self.isAlive=False def SvcDoRun(self): import servicemanager # Write a \u0026#39;started\u0026#39; event to the event log... (not required) # win32evtlogutil.ReportEvent(self._svc_name_,servicemanager.PYS_SERVICE_STARTED, 0, servicemanager.EVENTLOG_INFORMATION_TYPE,(self._svc_name_, \u0026#39;\u0026#39;)) # methode 1: wait for beeing stopped ... # win32event.WaitForSingleObject(self.hWaitStop, win32event.INFINITE) # methode 2: wait for beeing stopped ... self.timeout=1000 # In milliseconds (update every second) while self.isAlive: # wait for service stop signal, if timeout, loop again rc=win32event.WaitForSingleObject(self.hWaitStop, self.timeout) print \u0026#34;looping\u0026#34; # and write a \u0026#39;stopped\u0026#39; event to the event log (not required) # win32evtlogutil.ReportEvent(self._svc_name_,servicemanager.PYS_SERVICE_STOPPED, 0, servicemanager.EVENTLOG_INFORMATION_TYPE,(self._svc_name_, \u0026#39;\u0026#39;)) self.ReportServiceStatus(win32service.SERVICE_STOPPED) return if __name__ == \u0026#39;__main__\u0026#39;: # if called without argvs, let\u0026#39;s run ! if len(sys.argv) == 1: try: evtsrc_dll = os.path.abspath(servicemanager.__file__) servicemanager.PrepareToHostSingle(aservice) servicemanager.Initialize(\u0026#39;aservice\u0026#39;, evtsrc_dll) servicemanager.StartServiceCtrlDispatcher() except win32service.error, details: if details[0] == winerror.ERROR_FAILED_SERVICE_CONTROLLER_CONNECT: win32serviceutil.usage() else: win32serviceutil.HandleCommandLine(aservice)  原文链接  ","date":"2013-11-09T00:00:00Z","permalink":"https://zhw.in/post/windows-service-example-using-pyinstaller/","title":"windows service example using pyInstaller"},{"content":"介绍 pySerial\n封装了串口通讯模块，支持Linux、Windows、BSD(可能支持所有支持POSIX的操作系统)，支持Jython(Java)和IconPython(.NET and Mono).\n首页 http://pyserial.sf.net/\n特性  所有平台使用同样的类接口 端口号默认从0开始，程序中不需要知道端口名称 像文件读写一样的API，read、write（readline等也受支持） 所有程序全由Python完成，除了标准库外不依赖其他包，除了pywin32(windows)、JavaComm(Jython). POSIX(Linux, BSD) 只依赖Python标准库。  依赖环境  Python2.2或更新版本 windows 上的 pywin32扩展 Java/Jython上的 \u0026ldquo;Java Communications\u0026rdquo; (JavaComm)或者兼容包  安装 pip/easy_install\npip install pyserial easy_install pyserial  windows\n下载地址 ： http://sourceforge.net/project/showfiles.php?group_id=46487\n快速上手 Open port 0 at \u0026ldquo;9600,8,N,1\u0026rdquo;, no timeout\n\u0026gt;\u0026gt;\u0026gt; import serial \u0026gt;\u0026gt;\u0026gt; ser = serial.Serial(0) # open first serial port \u0026gt;\u0026gt;\u0026gt; print ser.portstr # check which port was really used \u0026gt;\u0026gt;\u0026gt; ser.write(\u0026quot;hello\u0026quot;) # write a string \u0026gt;\u0026gt;\u0026gt; ser.close() # close port  Open named port at \u0026ldquo;19200,8,N,1\u0026rdquo;, 1s timeout\n\u0026gt;\u0026gt;\u0026gt; ser = serial.Serial('/dev/ttyS1', 19200, timeout=1) \u0026gt;\u0026gt;\u0026gt; x = ser.read() # read one byte \u0026gt;\u0026gt;\u0026gt; s = ser.read(10) # read up to ten bytes (timeout) \u0026gt;\u0026gt;\u0026gt; line = ser.readline() # read a '/n' terminated line \u0026gt;\u0026gt;\u0026gt; ser.close()  Open second port at \u0026ldquo;38400,8,E,1\u0026rdquo;, non blocking HW handshaking\n\u0026gt;\u0026gt;\u0026gt; ser = serial.Serial(1, 38400, timeout=0, ... parity=serial.PARITY_EVEN, rtscts=1) \u0026gt;\u0026gt;\u0026gt; s = ser.read(100) # read up to one hundred bytes ... # or as much is in the buffer  Get a Serial instance and configure/open it later\n\u0026gt;\u0026gt;\u0026gt; ser = serial.Serial() \u0026gt;\u0026gt;\u0026gt; ser.baudrate = 19200 \u0026gt;\u0026gt;\u0026gt; ser.port = 0 \u0026gt;\u0026gt;\u0026gt; ser Serial\u0026lt;id=0xa81c10, open=False\u0026gt;(port='COM1', baudrate=19200, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=0, rtscts=0) \u0026gt;\u0026gt;\u0026gt; ser.open() \u0026gt;\u0026gt;\u0026gt; ser.isOpen() True \u0026gt;\u0026gt;\u0026gt; ser.close() \u0026gt;\u0026gt;\u0026gt; ser.isOpen() False  如果给定端口，端口将在创建对象之后立即打开，如果没有给定端口，可选timeout参数\ntimeout=None # wait forever timeout=0 # non-blocking mode (return immediately on read) timeout=x # set timeout to x seconds (float allowed)  Serial实例的可用方法 open() # 打开端口 close() # 立即关闭端口 setBaudrate(baudrate) # change baud rate on an open port inWaiting() # return the number of chars in the receive buffer read(size=1) # read \u0026quot;size\u0026quot; characters write(s) # 把字符串s写到该端口 flushInput() # 清除输入缓存区，放弃所有内容 flushOutput() # 清除输出缓冲区，放弃输出 sendBreak() # 发送中断条件 setRTS(level=1) # set RTS line to specified logic level setDTR(level=1) # set DTR line to specified logic level getCTS() # return the state of the CTS line getDSR() # return the state of the DSR line getRI() # return the state of the RI line getCD() # return the state of the CD line  Serial实例的属性 只读\nportstr # 设备名称 BAUDRATES # list of valid baudrates BYTESIZES # list of valid byte sizes PARITIES # list of valid parities STOPBITS # list of valid stop bit widths  下面属性值被更改后端口会重新配置，即使端口已经打开\nport # port name/number as set by the user baudrate # current baud rate setting bytesize # byte size in bits parity # parity setting stopbits # stop bit with (1,2) timeout # timeout setting xonxoff # if Xon/Xoff flow control is enabled rtscts # if hardware flow control is enabled  异常 serial.SerialException  常量 parity:\nserial.PARITY_NONE serial.PARITY_EVEN serial.PARITY_ODD  stopbits\nserial.STOPBITS_ONE al.STOPBITS_TWO  bytesize:\nserial.FIVEBITS serial.SIXBITS serial.SEVENBITS serial.EIGHTBITS  翻译(有删减)仅供参考\n原文地址：http://blog.csdn.net/dainiao01/article/details/5885122 官方文档：http://pyserial.sf.net/\n","date":"2013-10-26T00:00:00Z","permalink":"https://zhw.in/post/pyserial-python%E7%9A%84%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%9D%97/","title":"pySerial -- Python的串口通讯模块"},{"content":"使用django框架的autoreload在网站程序代码改动时重载应用。\n一般来说这种方法适用与所有的wsgi app, 这里只说下web.py和bottle\nbottle\nfrom bottle import run, Bottle app = Bottle() def dev_server(): run(app, host=\u0026#39;0.0.0.0\u0026#39;, port=8080, debug=True) if \u0026#39;__main__\u0026#39; == __name__: from django.utils import autoreload autoreload.main(dev_server) web.py\nfrom code import app def dev_server(): app.run() if __name__ == \u0026#34;__main__\u0026#34;: from django.utils import autoreload autoreload.main(dev_server) http://blog.est.im/post/34342180038\n","date":"2013-09-28T00:00:00Z","permalink":"https://zhw.in/post/%E4%BD%BF%E7%94%A8django%E6%A1%86%E6%9E%B6%E7%9A%84reloader%E9%87%8D%E8%BD%BDwsgi-app/","title":"使用django框架的reloader重载WSGI app"},{"content":"问题来源 gotit一直正常运行，现在不是成绩查询的时间了，访问量也少了不少。趁着这段时间打算重构下网站代码，当初上线之后总是添加功能或者应对正方教务系统，现在的代码非常乱。还有就是，正方查询的页面加载很慢，主要是登录之前的pre_login操作， 需要先访问一次正方教务系统，获取初始化用户状态(此处保存的是一个对象, 下面称其为zf)和中文验证码图片。\n相对其他页面的响应来说， 这段时间是最长的， 粗略测试了下，其时间在0.6～1.5秒之间不等，多次刷新的时候需要等待的时间更长，并且有的时候正方系统会响应不及时，导致无法获取用户状态。\n开始时，我打算将zf缓存到redis中，每一时刻都缓存若干个zf供用户使用，设置好过期时间，删除过期的zf，如果缓存的zf小于一定数目则进行获取，如此供用户使用，此时用户每次进行GET的时候仅从服务器本机获取数据而不用访问正方系统，一定会快很多。后来发现，并不是所有的对象都是能序列化(pickle)的。在《python标准库》中提到：\n 套接字、文件句柄、数据库链接以及其他运行时状态依然依赖操作系统或者其他进程的对象可能无法用一种有意义的方式保存。\n 需要缓存的zf对象就不能进行序列化，因为他依赖urllib2提供的opener，这样就不能使用redis进行缓存，只能将其缓存在内存中，比如保存在一个全局字典中，现在模拟登录的方法就是使用了一个字典保存用户get时获得的zf，用户post信息（学号、密码和验证码）后从字典中将zf读取出来，继续处理。\n多线程加速 开始 全部操作需要四个线程：   DaemonThread(D) : 守护线程\n 检测缓存字典中zf的数目 如果小于某一特定数值时则创建缓存（即创建zf） 如果大于该数目则等待    CreateThread(CR) : 创建缓存进程\n 守护线程的子线程 缓存不足的时候守护线程调用该线程创建缓存    CheckThread(CH) : 过期处理\n 检查缓存字典中的键值对是否过期 过期则POP    MainThread(M) : 调用上述线程\n 多线程调用    all_clients: 缓存没有使用过的zf\n 保存缓存的字典 结构： time_md5 -\u0026gt; (zf, viewstate, timeStart )    used_clients: 经过get操作的zf\n 用户进行get操作时，使用的键将从前者中pop到这个字典中，供后来的POST操作时模拟登录使用 结构： time_md5 -\u0026gt; (zf, viewstate, timeStart )    login_succeed: 登录成功的zf\n 供用户二次查询时使用 结构： time_md5 -\u0026gt; (zf, xh, timeStart )    temp_clients: 创建缓存时的中转字典\n 现将生成的zf放到这里，生成一定数量的时候，与all_clients合并，避免all_clients长期加锁。    相关变量  viewstate : 正方教务系统post时需要的一个参数，类似csrf\ntimeStart : 键值对的每一次操作都会将该值更新为当前时间\nxh : 查询者的学号, 供二次查询时其他查询使用\n 多线程相关 所有的线程都将setDaemon(True), 保证主线程结束后其他线程也相应结束。\n这里使用了threading提供的Condition对象，condition提供了对复杂线程的同步问题的一个解决方案， 也叫做条件变量，除了提供加锁、需求（acquire）和释放（release）方法外，还提供了停止等待（wait）和事件通知（notify）方法。\n在这里可以先判断字典的键值对数目，小于定值的时候D则创建若干个CR线程创建缓存, 每个CR线程创建一个zf即停止。如果大于定值则等待(不过这里不能时候wait，应为wait会一直阻塞，直到被notify), 这里让其继续判断。\n还有一个要说的是，python里字典和元组都是线程安全的，因为python对这两种数据结构的操作都是在字节码层次。\n具体方法 网站程序启动时调用M， M调用D \u0026amp; CH, D一直监控all_clients键值对的数目， CH每隔定值（与正方系统的验证码过期时间有关）检查一遍前三个字典中所有键的创建时间，大于定值则POP。\n对字典中的键值对进行过期检查的时候，现将整个字典copy一下，对copy的字典进行检测，将过期的键输出到列表中，统一pop，避免长期加锁，这也算浪费空间节约时间的一种方法吧。\n每个键的创建时间在每一次进行操作的时候都会变更为当前时间，就像正常上网时，每个一段时间刷新一次网页那登录就永远不会过期。\n(未完) ","date":"2013-09-13T00:00:00Z","permalink":"https://zhw.in/post/gotit%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%80%9F%E5%8F%8A%E7%BC%93%E5%AD%98/","title":"Gotit多线程加速及缓存"},{"content":"权限判断的装饰符 判断用户是否staff is_staff isn\u0026rsquo;t a permission so instead of permission_required you could use:\n@user_passes_test(lambda u: u.is_staff) #或者 from django.contrib.admin.views.decorators import staff_member_required @staff_member_required  link\n如果已经登陆则跳转 适用于方法 def ver_not_login(func): def ver(*args): request = args[0] if request.user.is_authenticated(): return HttpResponseRedirect(reverse_lazy(\u0026#39;index\u0026#39;)) else: return func(request) return ver 使用 @ver_not_login def register(request): pass 适用于url def ver_not_login_with_template(func): def ver(*args, **kwargs): request = args[0] template_name = kwargs[\u0026#39;template_name\u0026#39;] if request.user.is_authenticated(): return HttpResponseRedirect(reverse_lazy(\u0026#39;index\u0026#39;)) else: return func(request, template_name) return ver 使用 url(r\u0026#39;^$\u0026#39;, ver_not_login_with_template(login), {\u0026#39;template_name\u0026#39;:\u0026#39;login.html\u0026#39;}, ), 用户操作相关 组管理 添加用户到组 dian = Group.objects.filter(name=\u0026#39;dian\u0026#39;)[0] user.groups.add(dian)\n其他 调用django项目环境 from django.core.management import setup_environ import webtest.settings setup_environ(webtest.settings) django form ChoiceFields 遇到 too many values to unpack\nchoice 格式 (\u0026ldquo;label\u0026rdquo;:\u0026ldquo;内容\u0026rdquo;),(\u0026ldquo;label\u0026rdquo;:\u0026ldquo;内容\u0026rdquo;),\n遭遇 IOError: decoder jpeg not available\n安装libjpeg8-dev\n此处使用PIL或者pillow均可以，只要修改setup.py文件中库的引用位置\nhttp://three99.com/posts/how-to-install-pil-on-ubuntu-with-jpeg-support/\n","date":"2013-08-04T00:00:00Z","permalink":"https://zhw.in/post/django%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/","title":"django相关笔记"},{"content":"Gotit gotit开始时叫做正方教务系统查询工具, 仅用来帮助校外同学们查询本学期的成绩. gotit的名字只来源于我偶然买到的这个域名gotit.aisa, 当初.asia域名首年十八元促销, 就买到了这个. Gotit维护至今, 一直没有好好总结一下, 期间停停落落, 真的体会到了做产品的艰难, 出状况的时间不是自己说了算的, 使用人数多的时候每一秒都有十几个人同时访问, 每一个小小的失误, 都会给很多用户造成极大的困扰.\n2013-01-09至2013-07-31\n最初方法 使用urllib2模拟登录,然后使用BeaufitualSoup解析出所需的表格内容. 登录难点是url中有一段随机字符串,需要先将其匹配出来获得base_url, 一开始时是每一次登录都匹配一次该随机字符串,也就是说查询一次成绩程序要访问两次正方教务系统, 现在使用了马伟伟同学写的cache模块,每500秒获取一次该字符串,提高了成绩查询速度.另一个就是模拟登录时的post内容中有一个VIEWSTATE值, 类似与csrf_token吧, 登录时需要先抓取该值然后post.\ntest 部署相关  web.py  话说第一次上线比较急, 是直接通过web.py直接跑的, 不过也没怎么有压力, 估计是当初PV太低了\napache + mod_wsgi  这才算是第一次部署吧, 通过apache和mod_wsgi跑的web.py, 不过由于服务器上没有公网IP, 所以外面又加了一个nginx反向代理\n详见: http://zhwei.42qu.com/14334743#h21\napache + gunicorn  话说我是不太喜欢用apache的, 因为每次重启服务时还需要重启下apache, 太蛋疼了, 不过机器上的nginx是当初lnmp一键安装包里的, 很难用, 只能用自己装的apache了, gunicorn更pythoner点, 另外支持多线程.\n详见http://zhwei.42qu.com/14840780\nnginx + gunicorn  现在用的, 换了一台服务器, 配置好些, 原来的做备份用了.\n中文验证码 正方教务系统从原来的数字验证码到现在的中文验证码，尝试过验证码识别， 但是都不怎么理想，所以选择了让用户自己识别验证码，我们只模拟登陆。这样需要满足几个条件。\n首先，成功获取验证码并保存为图片，其中图片命名遇到了问题，起初选择了使用随机整型数字命名，由于程序中的随机都是伪随机， 重合率很高！后来选择了使用时间的MD5值，一直沿用到现在作为用户的唯一识别码，使time.time()获得的时间精确到0.001秒，以现在的用户访问量遇到在同一0.001秒同时访问几乎是不可能的，并且事实也是如此。\n用户需要在页面上直接输入学号、密码和验证码， 这就需要我们在用户第一次访问时就为其抓取下验证码供其识别，用户填写后由后台使用用户的数据进行模拟登陆从而抓取下成绩内容或者其他信息。而此处的难点是：怎样保证用户识别的验证码和他应该提交的验证码是同一个。因为正方系统还为每一个页面状态提供了一个VIEWSTATE参数，每次post都需要提供该参数。我一开始的想法是能够解析出每次抓取时的COOKIE不过后来想通了，由于每次都是在服务端抓取， 每次的COOKIE都是一样的，而每次的VIEWSTATE却是不一样的，所以这个方法被否定了。\nma6174同学想出了另一个方法，就是：创建一个独立于WEB.PY之外的字典，通过键值对的方式，将每一次处理时的对象直接保存起来，此处对象中有两个关键方法，一个是pre_login另一个是login，前者用于抓取验证码、viewstate，并且将此处的对象内容以某一KEY保存在字典中，该KEY开始时直接使用的VIEWSTATE，不过在本学期末发现: VIEWSTATE在一段时间内不变了, 这就导致了字典中的某一值一直被重写，不过这种情况在本地测试是正常的，因为只有一个人访问。为了避免这个问题就再次使用了上面说的time_md5。\n现在的做法就是：以time_md5为键，将由VIEWSTATE和对象组成的元组保存在全局字典中，验证码图片也是直接以time_md5命名，由于http的无状态，我们也懒得再弄一个cookie，所以直接将time_md5传到页面作为一个hidden input，之后再从post值中取出使用。\nURL中的随机字符串 相对来说，这个问题算很小的了，不过已有一些小纠结。第一次由于132的链接登陆后内容异常，只能使用133，而133的链接就多了这里的主角随机字符串, 当然这里随机是对我们来说的，正方教务系统后台肯定会有所控制，该字符串在一段时间内是不会发生改变的，我也只等了五分钟，对用户来说五分钟已经足够完成正常的查询功能了。\n解决方案: 每次抓取前先获取一下重定向后的链接, 匹配出随机字符串, 因为之后所有访问的url都需要此字符串, 这里也要保证登陆的url和登陆成功后抓取的url中的字符串是一致的, 不然肯定抓不到页面.\n之后有了中文验证码后, 再次使用133连接时(平时132能正常使用), 按以前的方法却出现了问题, 每次抓取前获取随即字符串在真正模拟登陆时却总是不行, 随后把获取重定向url的方法直接放在对象(保存到字典中的对象)中后就没问题了.\nAPIs 提供api\u0026hellip; 挺蛋疼的一件事\u0026hellip;现在提供的json格式的api, 文档见这里, 现在主要是完成了正方教务系统里的成绩查询, 考试时间查询和课表查询的格式还没有处理好.\n","date":"2013-07-31T00:00:00Z","permalink":"https://zhw.in/post/gotit%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/","title":"Gotit从零开始"},{"content":"脚本可见 https://gist.github.com/zhwei/5613474\n字典排序 line.118 dict1 = sorted(dict1.iteritems(), key=lambda k_v: (k_v[1], k_v[0]), reverse=True) # 字典按值排序, 生成元组列表 通过.iteritems()方法将字典转化成元组列表, 然后按元组的第二元素进行排序.\n文章查找 line.128 将博客文件读入列表\n对每一元素pop()使用find()方法查找关键词, 如果找到则将其插入列表首部, 循环一个列表长度后剩下的元素均是包含关键词的\nfor key in keys: i = 0 leng = len(artlist) while i \u0026lt; leng: d = artlist.pop() if d.find(key) != -1: artlist.insert(0, d) else: pass i = i + 1 然后可以再将处理后的文章列表作文参数传入, 再次匹配\n操作git line.177 每次敲git命令也是挺麻烦的, 做了一个全自动的, 除了需要自己写 commit message\n需要安装sh模块\ndef git(argv): \u0026#34;\u0026#34;\u0026#34; 将修改提交到git仓库 \u0026#34;\u0026#34;\u0026#34; try: import sh git = sh.git.bake(_cwd=ROOT_FILE) # 初始化 git, ROOT_FILE 为 .git 文件夹所在目录 except ImportError: print(\u0026#34;请安装 sh 模块\u0026#34;) try: argv[2] # 如果还有其他参数就返回 git status print(git.status()) except IndexError: print(git.add(\u0026#34;.\u0026#34;)) print(git.status()) m = raw_input(\u0026#34;|--commit message --\u0026gt;\u0026#34;) print(git.commit(m=m)) os.chdir(ROOT_FILE) print(\u0026#34;|--pushing to \u0026#34; + ORIGIN) os.system(\u0026#34;git push origin \u0026#34; + ORIGIN) git = sh.git.bake(_cwd=ROOT_FILE)\n初始化 git, ROOT_FILE 为 .git 文件夹所在目录\n","date":"2013-06-18T00:00:00Z","permalink":"https://zhw.in/post/%E6%9C%AC%E7%AB%99%E7%94%A8%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/","title":"本站用的管理工具"},{"content":"要交web基础作业了, 一直没想出做什么页面, 想起自己的博客没有一个aboutme页面, 又想学一下响应式布局, 所以, 如你所见: aboutme\n要针对不同的终端写不同的 css\n这是 bootstrap 的分辨率区间划分\n/* 大屏幕 */ @media (min-width: 1200px) { ... } /* 平板电脑和小屏电脑之间的分辨率 */ @media (min-width: 768px) and (max-width: 979px) { ... } /* 横向放置的手机和竖向放置的平板之间的分辨率 */ @media (max-width: 767px) { ... } /* 横向放置的手机及分辨率更小的设备 */ @media (max-width: 480px) { ... } 首先要在 head 里面加上 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt;\n然后在上面大括号中写不同分辨率的 css 样式就可以了\n这是我的\n/* 大屏幕 */ @media (min-width: 1200px) { .. } /* 横向放置的手机及分辨率更小的设备 */ @media (max-width: 480px) { /* 横向放置的手机和竖向放置的平板之间的分辨率 */ @media (min-width: 481px) and (max-width: 767px) { /* 小显示屏与横向平板之间的分辨率 */ @media (min-width: 768px) and (max-width: 979px) { /* 大屏小屏之间的分辨率 */ @media (min-width: 980px) and (max-width: 1199px) { 在某一分辨率区间的css时, 我的做法是直接将网页内容宽度直接定义为分辨率区间的最小值:\n/* 小显示屏与横向平板之间的分辨率 */ @media (min-width: 768px) and (max-width: 979px) { .container { width: 768px; /* \u0026lt;-- */ margin-left: auto; margin-right: auto; } 这样可以保证在此区间变动时, 网页样式不会发生变化.\nOT 一个简单的jquery对话框例子\n$(document).ready(function(){ $(\u0026#39;#me\u0026#39;).click(function(){$(\u0026#39;#layer\u0026#39;).fadeIn();}); //弹出层  $(\u0026#39;#close\u0026#39;).click(function(){$(\u0026#39;#layer\u0026#39;).fadeOut();}); //关闭层  });  点击 #me 的元素时, 弹出对话框, 对话框内容为 #layer, 可以在 #layer 中添加链接 #close , 点击可以关闭对话框.\n","date":"2013-06-16T00:00:00Z","permalink":"https://zhw.in/post/%E5%93%8D%E5%BA%94%E5%BC%8F%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/","title":"响应式页面设计"},{"content":"网络爬虫   抓取策略\n 宽度优先 非完全pagerank opic策略(cash) 大站优先    更新策略\n 历史参考(泊松建模) 用户体验 聚类抽样    暗网抓取\n  分布式爬虫\n 主从式 url 对等式 (哈希取模 \\ 一致性哈希 )    搜索引擎索引 基础  单词-文档 倒排  单词字典  哈希加链表 树形结构  倒排列表 单词 \u0026ndash;\u0026gt; 倒排列表\n建立列表  两遍 排序 单词id -\u0026gt; 文档ID -\u0026gt; 频率 归并  1 2 5 6 1 2 3 4\n索引更新  完全重建 再合并 原地更新 混合策略  查询  一次一文档 一次单词 跳跃指针 `\u0026lt;5 Pos1\u0026gt; 5,1 2,1 5,2 \u0026lt;13 Pos2\u0026gt; 13,1 2,1 5,2  ","date":"2013-06-15T00:00:00Z","permalink":"https://zhw.in/post/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-%E6%95%B4%E7%90%86/","title":"这就是搜索引擎 整理"},{"content":"最近对51开发板感兴趣, 用ma6174的51小板搞了下.\n不过上来就卡住了, 由于笔记本双系统 ubuntu+win8, 在win8下死活装不上 usb转串口的驱动程序, 只能考虑使用虚拟机. 由于使用的主系统是ubuntu, 所以选择在ubuntn中的virtualbox中安装xp.\nxp安装不讲\nusb映射 最需要的虚拟机的一个功能是usb映射, 系统中的vbox是通过ubuntu源安装的, 装好系统后google了好久都没有把usb映射搞好, 在官方论坛中找到了原因, ** ubuntu源安装的不支持usb映射 **\u0026hellip;\n官网下载安装好后, 运行提示没有权限控制usb子系统, 需要将用户添加到vboxusers用户组.\n\u0026quot;FAILED TO ACCESS THE USB SUBSYSTEM.....\n执行: sudo usermod -a -G vboxusers youruser\n建议注销一下\n-a 参数是将你的用户添加到新的用户组而不将你从原来的用户组中删除.\n现在已经能够进行usb映射了,如果是笔记本的话还能够自动识别内置摄像头.\n usb \nSTC ISP 握手失败 提示信息\nChinese:正在尝试与 MCU/单片机 握手连接 ... Chinese:连接失败，请尝试以下操作： 1.在单片机停电状态下，点下载按钮，再给单片机上电 ... 仍在连接中, 请给 MCU 上电... MCU Type is: STC89C52RC MCU Firmware Version: 4.3C Chinese:MCU 固件版本号: 4.3C Double speed / 双倍速: 12T/单倍速 振荡放大器增益: full gain 下次下载时 P1.0/P1.1 与下载无关 内部扩展AUX-RAM: 允许访问(强烈推荐) 下次下载用户应用程序时将数据Flash区擦除: NO 用户软件启动内部看门狗后: 复位关看门狗 内部时钟频率:11.059326M. 外部时钟频率:11.059326M. Chinese:正在重新连接 ... Connection failed. / 握手失败 (End: 17:23:05)  在 这里找到了一个原因:\n STC单片机下载引导程序需要CPU完全断电，注意：完全断电！完全断电！完全断电！\n  1、要知道电源并非只从VCC进入，其他管脚也可能有微弱电流，至于多大，并不是非得达到CPU工作的电流。\n2、说到这里，大家可能明白了一点，微弱电源就是从你已经连好的ISP下载线进入了，下载线供电能力，有个体和偶然因素，所以很多人换根线或是改改波特率就好了，会判断是下载线不兼容的假像！这个假相迷惑了数代有识青年，并当做教本教育下一代，呵呵。\n3、问题如何解决：STC串口线TXD串一个300-500欧电阻、RXD串一个IN4148，保证你从此告别STC下载烦劳。\n 我串联了两个180欧的电阻接上后还是握手失败, 又没有IN4148, 遂把最高波特率和最低波特率都改成2400, 了事.\nCurrent Baud is: / 当前波特率为: 2400 bps. We are erasing MCU flash... 正在擦除应用程序区... ( 00:01 ) 正在下载... ( 开始时间: 17:46:48 ) Program OK / 下载 OK Verify OK / 校验 OK erase times/擦除时间 : 00:01 program times/下载时间: 00:15 Encrypt OK/ 已加密  virtualbox运行时宿主机异常关机 Kernel driver not installed (rc=-1908) The VirtualBox Linux kernel driver (vboxdrv) is either not loaded or there is a permission problem with /dev/vboxdrv. Please reinstall the kernel module by executing '/etc/init.d/vboxdrv setup' as root. If it is available in your distribution, you should install the DKMS package first. This package keeps track of Linux kernel changes and recompiles the vboxdrv kernel module if necessary.  可以直接运行:\nsudo /etc/init.d/vboxdrv setup  ","date":"2013-06-10T00:00:00Z","permalink":"https://zhw.in/post/51%E6%9C%80%E5%B0%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E5%8F%8Avirtualbox%E7%9B%B8%E5%85%B3/","title":"51最小开发板使用记录及virtualbox相关"},{"content":" 原文作者:Rafe Kettler\n原文链接: A Guide to Python\u0026rsquo;s Magic Methods\nCopyright © 2012 Rafe Kettler\nVersion 1.17\n本文档的英文pdf版本在pdf或者Github. 我在这里建了一个repo, 所有的issues可以在那里报告, 当然也可是是评论, 更可以是赞助!\n 内容列表:\n 介绍 构造和初始化 在任意类中使用运算符 - 比较 magic methods - 数值 magic methods  介绍 这篇方法引导总结了几个月来的博客文章. 它的标题是 magic methods.\n什么事 magic methods? 它是面向对象的python中的所有东西. 它们是你能够自己向类中定义的特殊方法, 能够给你的类带来魔法般的效果! 它们以__开头以__结尾(eg: __init__或者__lt__). 它们的文档也比所期望的要少得多. python魔法方法总是出现在python文档的相同部分, 但是总是松散的, 并且很难在其中找到响应的案例, 当然也有可能是故意的, 所有的魔法方法在_语言参考 (language reference)_都有详细地列了出来, 附加还有令人厌烦的语法说明等等.\n所以呢, 为了修复我所感受到的python文档的不完美之处, 我着手为python magic methods准备一些更简明并且有详细案例的文档. 我开始每周整理一篇博客, 到现在为止我已经全部完成了, 整理成了这篇指导.\n我希望你能喜欢, 把它当做一篇教程 复习资料或者参考, 我仅仅希望他能作为一篇人性化的python magic methods指导.\n构造和初始化 每个人都知道最基础的 magic methods__init__, 我们可以用它来定义对象的初始化行为. 然而, 当我们调用x = SomeClass()时, __init__却不是第一个被调用的方法, 实际上被第一个调用的方法叫做__new__, 是它创建的实例并且将所有参数在创建的同时转递给初始化器. 在对象的预期的存活期限有一个__del__方法, 下面我们详细看下这三个方法:\n __new__(cls, [...)   __new__ 是在对象的初始化时调用的第一个方法, 它取走类然后将其他参数都传递给__init__, __new__用的真的很少, 但它也有其独到之处, 尤其是在将一个不可变的类型(例如元组或者字符串)子类化的时候. 我不想研究太多__new__的细节, 因为它用的真不怎么多, 但在python文档里有详细的介绍.   __init__(self, [...)   类的初始化器. 它获取在主要构造函数被调用时伴随的所有参数(例如: 我们在调用x = SomeClass(10, 'foo'))时, __init__获取10和'foo'作为参数. 在python类的定义时, 几乎人人都能用到__init__.   __del(self)__   如果__new__和__init__组成了对象的构造函数, 那么__del__就是析构函数. 它的功能不是通过del x来实现(那样的话代码会被转换成x.__del__()). 事实上, 它定义了当一个对象在垃圾回收时候的行为, 它对那些有可能不仅仅需要删除还需要额外清理的对象非常有用, 就像sockets或者文件对象(file objects). 但是要小心, 因为__del__没有任何保证不会在对象存活时间或者当解释器正在运行的时候运行. 所以__del__不能当做好的编码实践的替代品(有可能经常在你正在处理的时候断开链接). 其实, __del__最好永远不用, 因为当你调用它之后你已经处于\u0026quot;危险环境\u0026quot;之内, 一定要小心使用!  这里有一个__init__和__del__在实际中的使用:\nfrom os.path import join class FileObject: \u0026#39;\u0026#39;\u0026#39;Wrapper for file objects to make sure the file gets closed on deletion.\u0026#39;\u0026#39;\u0026#39; def __init__(self, filepath=\u0026#39;~\u0026#39;, filename=\u0026#39;sample.txt\u0026#39;): # open a file filename in filepath in read and write mode self.file = open(join(filepath, filename), \u0026#39;r+\u0026#39;) def __del__(self): self.file.close() del self.file 让运算符在任意类中使用 python magic methods最大的优势就是能够让对象向内置类型一样进行运算, 并且使用简单! 这就意味着你能够避免使用丑陋 违反语感 不标准的方法来实现基本运算符. 在很多语言中, 通常使用这种方法实现:\nif instance.equals(other_instance): # do something 当然你也可以在python中这样实现, 但这样添了很多不必要的麻烦. 不同的函数库也许使用不同的名字来命名相同的操作, 但这样会让客户端做很多额外的工作. 现在见识下 magic methods的强大之处吧, 我们可以定义这样一个方法(在案例中是__eq__), 然后我们能够实现:\nif instance == other_instance: #do something  这是python magic methods的强大的一方面, magic methods中的绝大部分是让我们能够定义运算符的实际操作, 从而使我们的类能够像内置类型一样进行各种运算.\n比较运算 magic methods python中设计了大量的魔法方法来通过运算符实现对象之间直观的比较, 而不是调用笨拙的方法。另外也提供了一种方法去通过引用重写Python对象之间默认的比较行为。下面就是这样的一系列方法和用法：\n  __cmp__(self, other)\n__cmp__方法是比较系列magic methods中最基础的方法。事实上它为其他的比较操作符(\u0026lt;, ==, != 等等)提供了提供了实现的方法,但是他的判断方式或许不是你想要的，比如说，判断某个实例是否与另一个实例相等是依据某个标准而是否大于则是依据另一个标准。__cmp__在self \u0026lt; other时返回一个负数，相等的时候返回0, self \u0026gt; other时返回正数。一般来说，最好分别定义你需要的操作符行为而不是一次性定义全部。但是在当你需要的比较操作都是依赖相似的标准时，__cmp__也是一种好方法来避免重复并且也能让代码更整洁。\n  __eq__(self, other)\n定义操作符**==**的行为\n  __ne__(self, other)\n定义操作符**!=**的行为\n  __lt__(self, other)\n定义操作符**\u0026lt;**的行为\n  __gt__(self, other)\n定义操作符**\u0026gt;**行为\n  __le__(self, other)\n定义操作符**\u0026lt;=**行为\n  __ge__(self, other)\n定义操作符**\u0026gt;=**行为\n  比如，我们把一个类想做一个单词，我们有可能需要按照字典的规则(字母表的顺序)比较, 而单词默认的比较是按照字符串比较。我们也有可能需要按照其他的标准来比较，诸如长度、数字、音节等，在下面的例子中我们按照单词的长度来比较，下面是具体实现：\nclass Word(str): \u0026#39;\u0026#39;\u0026#39;单词类, 依据单词的长度比较单词大小\u0026#39;\u0026#39;\u0026#39; def __new__(cls, word): # 注意到我们用了__new__方法, 因为字符串是不可变类型，这样我们初始化是更加方便。 if \u0026#39; \u0026#39; in word: print \u0026#34;单词中包含空格，这里取第一个空格前的单词.\u0026#34; word = word[:word.index(\u0026#39; \u0026#39;)] # Word is now all chars before first space return str.__new__(cls, word) def __gt__(self, other): return len(self) \u0026gt; len(other) def __lt__(self, other): return len(self) \u0026lt; len(other) def __ge__(self, other): return len(self) \u0026gt;= len(other) def __le__(self, other): return len(self) \u0026lt;= len(other) 现在我们通过Wrod(\u0026quot;foo\u0026quot;) and Word(\u0026quot;bar\u0026quot;)可以创建两个实例, 然后通过判断它们的长度比较大小，注意到我们这里没有定义__eq__和__ne__方法，这是因为如果定义了会导致一些怪异的行为，尤其是判断Word('foo') == Word('bar')会返回True，这样通过长度判定两个单词相等是没有意义的，所以我们让回落到字符串的范畴中判断是否相等。\n其实有时候我们需要大量比较操作的时候并不需要自己定义大量的magic method, 如果你只需要定义__eq__或者__gt__、__lt__等，Python的标准库functools中已经提供了一个很友好的类装饰器，这个特性只在Python2.7中可用，如果你有机会使用@total_ordering的话一定能节省大量的时间和精力。\n数值运算魔法方法 就像你可以使用某种方法让类可以通过比较操作符进行比较一样，你也可应定义他们使用数学运算符时的表现行为。睁大眼睛注意了，其实有很多这样的魔法方法，为了条理清晰，我把它们分为五类：一元运算符、普通算数运算符、反射算数运算符(稍后详述)、增量赋值和类型转换。\n一元运算符和方法 一元运算符只有一个操作数，比如：取反、绝对值等。\n__pos__(self)\n一元运算符取正值的实现 (e.g. +some_object)\n__neg__(self)\n一元运算符取反的实现(e.g. -some_object)\n__abs__(self)\n定义使用内置abs()方法时的行为\n__invert__(self)\n定义使用内置操作符～时的行为，具体实例见the Wikipedia article on bitwise operations\n__round__(self, n)\n定义使用内置方法round()时的行为, n是四舍五入时保留的小数位数\n__floor__(self)\n定义调用方法math.floor()时的行为， 返回离数字上舍整数\n__ceil__(self)\n定义调用方法math.ceil()时的行为， 返回离数字上舍整数\n__trunc__(self)\n定义调用方法math.trunc()时的行为， 截取数字的整数部分\n常用运算符 现在我们来看下常用的二元运算符以及几个方法(像：+，-，*等等), 这些中的大部分是很通俗易懂的。\n__add__(self, other)\n定义加法\n__sub__(self, other)\n定义减法\n__mul__(self, other)\n定义乘法\n__floordiv__(self, other)\n定义整除\n__div__(self, other)\n定义除法\n__truediv__(self, other)\n定义整数除法，只有在from __future__ import division 时使用\n__mod__(self, other)\n定义取模运算\n__divmod__(self, other)\n定义长除法，调用divmod()时的行为\n__pow__(self, other)\n定义运算符**\n__lshift__(self, other)\n定义左移运算符\u0026lt;\u0026lt;\n__rshift__(self, other)\n定义右移运算符\u0026gt;\u0026gt;\n__and__(self, other)\n定义按位与，\u0026amp;操作符\n__or__(self, other)\n定义按位或，|操作符\n__xor__(self, other)\n定义按位异或， ^操作符\n反运算操作符 ","date":"2013-05-21T00:00:00Z","permalink":"https://zhw.in/post/%E7%BF%BB%E8%AF%91a-guide-to-pythons-magic-methods/","title":"[翻译]A Guide to Python's Magic Methods"},{"content":"mysql初始化密码 /etc/init.d/mysql stop # mysqld_safe --user=mysql --skip-grant-tables --skip-networking \u0026amp; # mysql -u root mysql mysql\u0026gt; UPDATE user SET Password=PASSWORD('newpassword') where USER='root'; mysql\u0026gt; FLUSH PRIVILEGES; mysql\u0026gt; quit # /etc/init.d/mysql restart # mysql -uroot -p Enter password: \u0026lt;输入新设的密码newpassword\u0026gt;  ###获取最后n个字段\n建临时表带自动增1的id字段\nselect top 5 * from temp_table order by id desc  ","date":"2013-05-20T00:00:00Z","permalink":"https://zhw.in/post/sql%E5%A4%87%E5%BF%98/","title":"sql备忘"},{"content":"安装包管理 Ctrl + ` import urllib2,os; pf=\u0026lsquo;Package Control.sublime-package\u0026rsquo;; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),\u0026lsquo;wb\u0026rsquo;).write(urllib2.urlopen(\u0026lsquo;http://sublime.wbond.net/'+pf.replace(' \u0026lsquo;,'%20\u0026rsquo;)).read()); print \u0026lsquo;Please restart Sublime Text to finish installation\u0026rsquo; 回车\n快捷键 安装插件,以Alignment为例\nShift + Ctrl + p install alignment  代码补齐\nShift + Ctrl + a  zencoding Ctrl + Alt + Enter div#page\u0026gt;div.logo+ul#navigation\u0026gt;li*5\u0026gt;a \u0026lt;div id=\u0026quot;page\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;logo\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;ul id=\u0026quot;navigation\u0026quot;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt;  vim模式 Shift + Ctrl + P 输入settings user 调出Preferences：Settings - User 打开Preferences.sublime-settings文件 将文件中方括号中的\u0026quot;Vintage\u0026quot;删掉，sublime默认是将其ignored的 最后是酱紫滴：\n{ \u0026quot;ignored_packages\u0026quot;:[] }  jinjia2 插件jinjia2方便jinjia2模板语言的书写, 初始化文件 ctrl + shift + p ssjinjia\nauto pep8插件 rt 快捷键\nctrl + shift +8 自动排版 ctrl + 8 预览  ","date":"2013-03-25T00:00:00Z","permalink":"https://zhw.in/post/sublime-text-2-%E5%A4%87%E5%BF%98/","title":"sublime text 2 备忘"},{"content":"学习使用socket模块 2013-01-30 创建tcp服务器 客户端时,遇到如下错误,由于不能上网,无法查询特此记录\nTraceback (most recent call last): File \u0026ldquo;tsTserv.py\u0026rdquo;, line 21, in data = tcpSerSock.recv(BUFSIZ) File \u0026ldquo;/usr/lib/python2.7/socket.py\u0026rdquo;, line 170, in _dummy raise error(EBADF, \u0026lsquo;Bad file descriptor\u0026rsquo;) socket.error: [Errno 9] Bad file descriptor\n","date":"2013-01-30T00:00:00Z","permalink":"https://zhw.in/post/%E5%AF%92%E5%81%87%E8%AE%B0%E5%BD%95/","title":"寒假记录"},{"content":"安装 gem install vagrant  Vagrant Official Boxes https://github.com/mitchellh/vagrant/wiki/Available-Vagrant-Boxes\n使用 第一次使用,进入工作目录 vagrant box add lucid32 http://files.vagrantup.com/lucid32.box #初始化虚拟机 vagrant init lucid32 #启动虚拟机 vagrant up #ssh进入 vagrant ssh #关闭虚拟机 vagrant halt #打包虚拟机 vagrant package --output base-ubuntu-rvm.box  配置文件 Vagrantfile 端口转发\n#将虚拟机80端口转发到宿主机8080端口 config.vm.forward_port 80, 8080  ","date":"2013-01-25T00:00:00Z","permalink":"https://zhw.in/post/vagrant-%E5%A4%87%E5%BF%98/","title":"vagrant 备忘"},{"content":"###首先卸载曾经的显卡驱动 sudo apt-get remove \u0026ndash;purge fglrx fglrx-amdcccle fglrx-dev\n###安装闭源前准备的库 sudo apt-get install build-essential cdbs fakeroot dh-make debhelper debconf libstdc++6 dkms libqtgui4 wget execstack libelfg0 dh-modaliases linux-headers-generic\n###如果是64位ubuntu,安装32位库: sudo apt-get install ia32-libs\n###然后下载最新催化剂驱动\nwget http://www2.ati.com/drivers/linux/amd-driver-installer-catalyst-12.10-x86.x86_64.zip\nunzip amd-driver-installer-catalyst-12.10-x86.x86_64.zip\nchmod +x amd-driver-installer-catalyst-12.10-x86.x86_64.run\n###创建deb安装包并安装\nsudo sh ./amd-driver-installer-catalyst-12.10-x86.x86_64.run \u0026ndash;buildpkg Ubuntu/precise\nsudo dpkg -i fglrx*.deb\n###生成配置文件：\nsudo aticonfig \u0026ndash;initial -f\n###防止配置未生效： sudo aticonfig \u0026ndash;input=/etc/X11/xorg.conf \u0026ndash;tls=1\n重启检查是否成功 fglrxinfo\n以上来自Ubuntu Precise Installation Guide\n实测后报错\nX Error of failed request: BadRequest (invalid request code or no such operation)\n有重新执行了一遍,删除了xorg.comf 文件 sudo apt-get install \u0026ndash;reinstall libgl1-mesa-glx:i386 libgl1-mesa-dri:i386 xserver-xorg-core sudo dpkg-reconfigure xserver-xorg\n重启后成功了.\n","date":"2012-12-13T00:00:00Z","permalink":"https://zhw.in/post/thankpad-e420-ubuntu-%E5%8F%8C%E6%98%BE%E5%8D%A1%E9%85%8D%E7%BD%AE/","title":"thankpad E420 ubuntu 双显卡配置"},{"content":"###总结 刚刚看了浮云比翼同学的博客,感觉每月总结一些还是很必要的,每次想写博客的时候总是怕麻烦,然后就不了了之了,想这样给自己一个强制性的要求,每个月多多少少写一些,等回过头来看时,不会是一片空白.\n最近这个月真的干了不少事,因为有项目压在手里的缘故吧,一直很忙,现在在做一个汽配商城的网站,后台功能已经差不多了,下周左右就可以着手写前台了,不过对前端真的不怎么感冒,现在是打算找一个类似的站点直接copy吧,罪过罪过\u0026hellip;\n很多学长都说过做项目时学到的东西最多也最快,现在真的体会到了,后台使用python写的,django框架,以前也看过好久文档和django book 当写起来时还是发现没什么思路,行胜于言,要铭记于心,不能光靠嘴上说的,一定要即使练习,快速记忆.\n###djang使用\n之前用过web.py,算是一个小型框架吧,虽然现在越来越大,相对djangoi之类还是算小型.这算我第一次使用框架吧,真的感觉到了框架的便利之处,这个在webpy中感受不怎么明显,django的用户多,第三方的组建也很多,最近用了几个:\n djang-mptt 让django在数据库中存储层级结构 djang-south 检测对model的修改病痛不到数据库 django-filebrowser 基于grappelli的文件管理器  ###各种向往中\n js ajax jQuery\n\u0026hellip;\n各种不了解\u0026hellip; ","date":"2012-12-03T00:00:00Z","permalink":"https://zhw.in/post/11%E6%9C%88%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/","title":"11月月度总结"},{"content":"注释 用\u0026quot;#\u0026ldquo;注释当前行\n:s/^/#  在2~50行首添加\u0026rdquo;#\u0026ldquo;注释\n:2,50s/^ /#  用\u0026rdquo;#\u0026ldquo;注释当前行和当前行后面的三行\n:.,+3s/^/#  用\u0026rdquo;#\u0026ldquo;注释所有行\n:%s/^/#  补全 英文单词补全\nset dictionary+=/usr/share/dict/words CTRL-X_CTRL-K  包含路径及文件名\nCTRL-X_CTRL-F  曾经输入过的变量名或字符串\nCTRL-N  行补全 CTRL-X_CTRL-L 万能补全 filetype plugin on CTRL-X_CTRL-O\nvim 256色问题 自从转战kde后一直忍受konsole中难看的vim主题, 也找了好多对策,比如使用gvim..转战sublime等等, 但终究是不方便. 今天才知道是konsole默认不支持256色的问题,在~/.vimrc中添加了下面两句后解决了 \u0026ldquo;解决konsole 256 色显示问题\nlet g:solarized_termcolors=256 set t_Co=256  ","date":"2012-11-25T00:00:00Z","permalink":"https://zhw.in/post/vim%E5%A4%87%E5%BF%98/","title":"vim备忘"},{"content":"很久没更新的ubuntu12.04更新了下，结果直接挂掉了。。。 前几天装上了新出的12.10，gnome还是老样子，效果有一丢丢改进. 为了以后安装方便，很多环境的配置方法记录下。\n为了使用pyCharm，要用sun jdk，openjdk明显不给力。。。\nsunjdk文件可以在oracle，已经保存到百度网盘。\nchmod +x jdk-6u32-linux-x64.bin sudo ./jdk-6u32-linux-x64.bin sudo mv jdk1.6.0_32 /usr/lib/jvm/ #配置环境变量，这是更改后的 PATH=\u0026quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/jvm/jdk1.6.0_34/bin\u0026quot; CLASSPATH=\u0026quot;/usr/lib/jvm/jdk1.6.0_34/lib\u0026quot; JAVA_HOME=\u0026quot;/usr/lib/jvm/jdk1.6.0_34\u0026quot;  ruby on rails\n","date":"2012-11-23T00:00:00Z","permalink":"https://zhw.in/post/ubuntu12.10-%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/","title":"ubuntu12.10 配置记录"},{"content":"##入手\n 前几天入手的nook color，新刷的cm7系统，主要是为了看书购入的，感觉还不错，ips屏还是比较给力的。\n还有一个号称二十美刀的原装皮套，不过感觉好沉。。。\n##使用\n cm7默认将内置存储挂载到emmc，但是软件安装是要求必须有内存卡，在购进一个card太麻烦了，看了一下cm7的fstab\n位置：/system/etc/vold.fstab\ndev_mount sdcard /mnt/sdcard auto /devices/platform/mmci-omap-hs.1/mmc_host/mmc1 #改成 dev_mount sdcard /mnt/sdcard 8 /devices/platform/mmci-omap-hs.1/mmc_host/mmc0  pdf mobi epub 阅读用的是静读天下专业版\nhtml用 iReader\n","date":"2012-11-10T00:00:00Z","permalink":"https://zhw.in/post/my-nook-color/","title":"my nook color"},{"content":" 经过各种纠结，jekyll博客终于建成了，如你所见.  ","date":"2012-10-25T00:00:00Z","permalink":"https://zhw.in/post/first-blog/","title":"first blog"},{"content":"配置文件 my.cnf 默认字符集为 utf-8 default-character-set = utf-8 character-set-server= utf-8  mysql 命令 mysql设置编码命令 SET character_set_client = utf8; SET character_set_connection = utf8; SET character_set_database = utf8; SET character_set_results = utf8;/*这里要注意很有用*/ SET character_set_server = utf8; SET collation_connection = utf8_bin; SET collation_database = utf8_bin; SET collation_server = utf8_bin; #查看数据库编码 show variables like 'characte%'; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ #创建数据库时指定编码 #GBK: create database test2 DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci; #UTF8: CREATE DATABASE `test2` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci #数据库连接串中指定字符集 URL=jdbc:mysql://yourIP/college?user=root\u0026amp;password=yourPassword\u0026amp;useUnicode=true\u0026amp;characterEncoding=gbk  ","date":"2012-10-25T00:00:00Z","permalink":"https://zhw.in/post/mysql-%E7%BC%96%E7%A0%81%E7%9B%B8%E5%85%B3/","title":"mysql 编码相关"}]