<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gotit on zhwei's Blog</title><link>https://zhw.in/tags/gotit/</link><description>Recent content in Gotit on zhwei's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 18 Feb 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://zhw.in/tags/gotit/index.xml" rel="self" type="application/rss+xml"/><item><title>Gotit改进与待做</title><link>https://zhw.in/post/gotit%E6%94%B9%E8%BF%9B%E4%B8%8E%E5%BE%85%E5%81%9A/</link><pubDate>Tue, 18 Feb 2014 00:00:00 +0000</pubDate><guid>https://zhw.in/post/gotit%E6%94%B9%E8%BF%9B%E4%B8%8E%E5%BE%85%E5%81%9A/</guid><description>Gotit 近段时间的改进和以后一段时间内的更新计划，挖坑的时间到了，准备跳票。
改进 使用requests替代urllib requests的确是HTTP library human， 自动处理文字编码、灵活的cookie操作，的确赏心悦目！并且它的cookie支持pickle，因此可以直接将每次的请求缓存到redis，相对于以前缓存整个对象到内存中的全局字典，不得不说更稳定灵活了好多！
重写正方查询的类与缓存机制 原来的正方类是与自己写的缓存紧密耦合的，旧的缓存机制使用内存全局字典作为存放地点，创建缓存与缓存过期判断都是由多个线程判断，并且某些线程在特定条件下还会创建更多子线程，到了最后虽然能正常工作但不得不说成了像shi一样的代码。现在所有缓存都放在redis中，缓存的过期时间完全由redis控制，只在用户每次查询操作时重置缓存时间就可以了。
完善异常处理 一直没有想到正方教务系统竟然有那么多的报错提醒，由于其多数请求异常都是弹窗提醒，所以可以通过特定的正则表达式匹配出多数的弹窗提醒，在每次页面请求后都会检测是否有弹窗警告，主要是登录时候的报错，新生没有更改初始密码是不能进行查询的。
彻底放弃了bs3分支 bs3分支就是上面说的时候大量线程进行提前缓存，当时还写了一篇博客，后来发现，出现的问题远大于解决的问题，并且大量线程在正方系统发生宕机或者其他异常时候会一直阻塞，也一直找不到合适的解决方案，痛苦了好久后决定放弃该分支，继续升级维护2.0-stable分支。但是已经将bs3中的Bootstrap3界面迁移到了2.0分支。
待做 优化缓存 有些时候用户查询到的内容是没有发生变化的，打算将用户查询到的内容缓存到redis中，并且某些时候（例如过年前后）正方教务系统可能会直接停止，在这种情况下可以通过使用长期缓存。 另外可以在用户查询单个内容时，为用户将其他内容缓存。（例如当张三在查询当前学期成绩时，返回成绩后继续将他的课表、绩点、考试时间等内容缓存，如果他继续查询其他内容，响应速度将会大量提高，不再受正方、网络延时的影响。
优化移动端页面 移动端的浏览量与PC端的浏览量相差无几， 移动端需要优化的主要是查询结果页面的表格，前段时间迁移bootstrap3后使用了bs的响应式表格，但是在uc浏览器上无法使用，所以又添加了一个表格调整的按钮切换回旧的样式。这也是一个急需解决的问题。
网站后台 话说到现在为止gotit是没有网站后台的，所有的配置都是写在配置文件中，好吧，话说主要是想偷懒。现在后台已经在开发之中，包括每个页面的公告、网站公告、捐献者等内容，当然还有网站的各种日志，也不希望每次都要远程到服务器上才能看到到底发生了什么。 还有一个目的就是积累用户啦，主要推广方法还是靠下一个内容了。
成绩更新提醒 成绩提醒，就是在成绩更新后及时通知给相应的用户，这里只要保留cookie就行了，不过由于神一样的正方教务系统在大量请求下极其脆弱，每一次宕机cookie就失效了，再由于中文验证码的存在，还没有完善的解决方案，所以算是一个超级Beta内容了，将来只会对捐献者开放这项功能。</description></item><item><title>Gotit多线程加速及缓存</title><link>https://zhw.in/post/gotit%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%80%9F%E5%8F%8A%E7%BC%93%E5%AD%98/</link><pubDate>Fri, 13 Sep 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/gotit%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%80%9F%E5%8F%8A%E7%BC%93%E5%AD%98/</guid><description>问题来源 gotit一直正常运行，现在不是成绩查询的时间了，访问量也少了不少。趁着这段时间打算重构下网站代码，当初上线之后总是添加功能或者应对正方教务系统，现在的代码非常乱。还有就是，正方查询的页面加载很慢，主要是登录之前的pre_login操作， 需要先访问一次正方教务系统，获取初始化用户状态(此处保存的是一个对象, 下面称其为zf)和中文验证码图片。
相对其他页面的响应来说， 这段时间是最长的， 粗略测试了下，其时间在0.6～1.5秒之间不等，多次刷新的时候需要等待的时间更长，并且有的时候正方系统会响应不及时，导致无法获取用户状态。
开始时，我打算将zf缓存到redis中，每一时刻都缓存若干个zf供用户使用，设置好过期时间，删除过期的zf，如果缓存的zf小于一定数目则进行获取，如此供用户使用，此时用户每次进行GET的时候仅从服务器本机获取数据而不用访问正方系统，一定会快很多。后来发现，并不是所有的对象都是能序列化(pickle)的。在《python标准库》中提到：
套接字、文件句柄、数据库链接以及其他运行时状态依然依赖操作系统或者其他进程的对象可能无法用一种有意义的方式保存。
需要缓存的zf对象就不能进行序列化，因为他依赖urllib2提供的opener，这样就不能使用redis进行缓存，只能将其缓存在内存中，比如保存在一个全局字典中，现在模拟登录的方法就是使用了一个字典保存用户get时获得的zf，用户post信息（学号、密码和验证码）后从字典中将zf读取出来，继续处理。
多线程加速 开始 全部操作需要四个线程： DaemonThread(D) : 守护线程
检测缓存字典中zf的数目 如果小于某一特定数值时则创建缓存（即创建zf） 如果大于该数目则等待 CreateThread(CR) : 创建缓存进程
守护线程的子线程 缓存不足的时候守护线程调用该线程创建缓存 CheckThread(CH) : 过期处理
检查缓存字典中的键值对是否过期 过期则POP MainThread(M) : 调用上述线程
多线程调用 all_clients: 缓存没有使用过的zf
保存缓存的字典 结构： time_md5 -&amp;gt; (zf, viewstate, timeStart ) used_clients: 经过get操作的zf
用户进行get操作时，使用的键将从前者中pop到这个字典中，供后来的POST操作时模拟登录使用 结构： time_md5 -&amp;gt; (zf, viewstate, timeStart ) login_succeed: 登录成功的zf</description></item><item><title>Gotit从零开始</title><link>https://zhw.in/post/gotit%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</link><pubDate>Wed, 31 Jul 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/gotit%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</guid><description>Gotit gotit开始时叫做正方教务系统查询工具, 仅用来帮助校外同学们查询本学期的成绩. gotit的名字只来源于我偶然买到的这个域名gotit.aisa, 当初.asia域名首年十八元促销, 就买到了这个. Gotit维护至今, 一直没有好好总结一下, 期间停停落落, 真的体会到了做产品的艰难, 出状况的时间不是自己说了算的, 使用人数多的时候每一秒都有十几个人同时访问, 每一个小小的失误, 都会给很多用户造成极大的困扰.
2013-01-09至2013-07-31
至今趋势
最初方法 使用urllib2模拟登录,然后使用BeaufitualSoup解析出所需的表格内容. 登录难点是url中有一段随机字符串,需要先将其匹配出来获得base_url, 一开始时是每一次登录都匹配一次该随机字符串,也就是说查询一次成绩程序要访问两次正方教务系统, 现在使用了马伟伟同学写的cache模块,每500秒获取一次该字符串,提高了成绩查询速度.另一个就是模拟登录时的post内容中有一个VIEWSTATE值, 类似与csrf_token吧, 登录时需要先抓取该值然后post.
test 部署相关 web.py 话说第一次上线比较急, 是直接通过web.py直接跑的, 不过也没怎么有压力, 估计是当初PV太低了
apache + mod_wsgi 这才算是第一次部署吧, 通过apache和mod_wsgi跑的web.py, 不过由于服务器上没有公网IP, 所以外面又加了一个nginx反向代理
详见: http://zhwei.42qu.com/14334743#h21
apache + gunicorn 话说我是不太喜欢用apache的, 因为每次重启服务时还需要重启下apache, 太蛋疼了, 不过机器上的nginx是当初lnmp一键安装包里的, 很难用, 只能用自己装的apache了, gunicorn更pythoner点, 另外支持多线程.
详见http://zhwei.42qu.com/14840780
nginx + gunicorn 现在用的, 换了一台服务器, 配置好些, 原来的做备份用了.
中文验证码 正方教务系统从原来的数字验证码到现在的中文验证码，尝试过验证码识别， 但是都不怎么理想，所以选择了让用户自己识别验证码，我们只模拟登陆。这样需要满足几个条件。
首先，成功获取验证码并保存为图片，其中图片命名遇到了问题，起初选择了使用随机整型数字命名，由于程序中的随机都是伪随机， 重合率很高！后来选择了使用时间的MD5值，一直沿用到现在作为用户的唯一识别码，使time.time()获得的时间精确到0.001秒，以现在的用户访问量遇到在同一0.001秒同时访问几乎是不可能的，并且事实也是如此。</description></item></channel></rss>