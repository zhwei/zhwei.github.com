<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on zhwei's Blog</title><link>https://zhw.in/tags/python/</link><description>Recent content in Python on zhwei's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 10 Nov 2013 00:00:00 +0000</lastBuildDate><atom:link href="https://zhw.in/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Pyinstaller打包Python写的windows服务-记录</title><link>https://zhw.in/post/pyinstaller%E6%89%93%E5%8C%85python%E5%86%99%E7%9A%84windows%E6%9C%8D%E5%8A%A1-%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 10 Nov 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/pyinstaller%E6%89%93%E5%8C%85python%E5%86%99%E7%9A%84windows%E6%9C%8D%E5%8A%A1-%E8%AE%B0%E5%BD%95/</guid><description>由来 最近在写一个服务器监控平台，python开发，前端标准bootstrap，后端Bottle, 数据库mongodb，要写服务器监控肯定少不了客户端了，客户端主要用到了XMLRPCServer, 服务端与客户端通过xml通信，这个在python的标准库里，还是可以信赖的，并且支持http验证，此处不赘言，以后再讲。linux上的客户端很好搞，因为linux自带python解释器，不管版本如何，使用起来还是很好改的， 最头疼的是window下的客户端，以前很少在win下做开发，python环境也是随意搭了一下，正使用的时候还是各种DT。。。
花了一段时间写了一个win下的python程序，不过依赖很多，包括pywin32、wmi，并且python的安装还需要改注册表，作为一个监控，如果还需要在服务器上安装python环境等东西有点得不偿失了。找到了pyinstaller和py2exe，能够将python程序打包成可执行的exe文件，复制到其他机器上可以直接执行，下面进入正题！
各种环境安装 安装pywin32、wmi弹框 Python version 2.7 required, which was not found in the registry 在注册表中找不到python，使用下面的一个脚本放在c盘根目录执行下就可以, 见Link
程序 # SmallestService.py # # A sample demonstrating the smallest possible service written in Python. import win32serviceutil import win32service import win32event class SmallestPythonService(win32serviceutil.ServiceFramework): _svc_name_ = &amp;#34;SmallestPythonService&amp;#34; _svc_display_name_ = &amp;#34;The smallest possible Python Service&amp;#34; def __init__(self, args): win32serviceutil.ServiceFramework.__init__(self, args) # Create an event which we will use to wait on.</description></item><item><title>windows service example using pyInstaller</title><link>https://zhw.in/post/windows-service-example-using-pyinstaller/</link><pubDate>Sat, 09 Nov 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/windows-service-example-using-pyinstaller/</guid><description>用python写的windows服务，支持pyinstaller打包。 # Usage: # service.exe install # service.exe start # service.exe stop # service.exe remove # you can see output of this program running python site-packages win32libwin32traceutil import win32service import win32serviceutil import win32event import win32evtlogutil import win32traceutil import servicemanager import winerror import time import sys import os class aservice(win32serviceutil.ServiceFramework): _svc_name_ = &amp;#34;aservice&amp;#34; _svc_display_name_ = &amp;#34;aservice - It Does nothing&amp;#34; _svc_deps_ = [&amp;#34;EventLog&amp;#34;] def __init__(self,args): win32serviceutil.ServiceFramework.__init__(self,args) self.hWaitStop=win32event.CreateEvent(None, 0, 0, None) self.</description></item><item><title>pySerial -- Python的串口通讯模块</title><link>https://zhw.in/post/pyserial-python%E7%9A%84%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%9D%97/</link><pubDate>Sat, 26 Oct 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/pyserial-python%E7%9A%84%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%9D%97/</guid><description>介绍 pySerial
封装了串口通讯模块，支持Linux、Windows、BSD(可能支持所有支持POSIX的操作系统)，支持Jython(Java)和IconPython(.NET and Mono).
首页 http://pyserial.sf.net/
特性 所有平台使用同样的类接口 端口号默认从0开始，程序中不需要知道端口名称 像文件读写一样的API，read、write（readline等也受支持） 所有程序全由Python完成，除了标准库外不依赖其他包，除了pywin32(windows)、JavaComm(Jython). POSIX(Linux, BSD) 只依赖Python标准库。 依赖环境 Python2.2或更新版本 windows 上的 pywin32扩展 Java/Jython上的 &amp;ldquo;Java Communications&amp;rdquo; (JavaComm)或者兼容包 安装 pip/easy_install
pip install pyserial easy_install pyserial windows
下载地址 ： http://sourceforge.net/project/showfiles.php?group_id=46487
快速上手 Open port 0 at &amp;ldquo;9600,8,N,1&amp;rdquo;, no timeout
&amp;gt;&amp;gt;&amp;gt; import serial &amp;gt;&amp;gt;&amp;gt; ser = serial.Serial(0) # open first serial port &amp;gt;&amp;gt;&amp;gt; print ser.portstr # check which port was really used &amp;gt;&amp;gt;&amp;gt; ser.</description></item><item><title>使用django框架的reloader重载WSGI app</title><link>https://zhw.in/post/%E4%BD%BF%E7%94%A8django%E6%A1%86%E6%9E%B6%E7%9A%84reloader%E9%87%8D%E8%BD%BDwsgi-app/</link><pubDate>Sat, 28 Sep 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/%E4%BD%BF%E7%94%A8django%E6%A1%86%E6%9E%B6%E7%9A%84reloader%E9%87%8D%E8%BD%BDwsgi-app/</guid><description>使用django框架的autoreload在网站程序代码改动时重载应用。
一般来说这种方法适用与所有的wsgi app, 这里只说下web.py和bottle
bottle
from bottle import run, Bottle app = Bottle() def dev_server(): run(app, host=&amp;#39;0.0.0.0&amp;#39;, port=8080, debug=True) if &amp;#39;__main__&amp;#39; == __name__: from django.utils import autoreload autoreload.main(dev_server) web.py
from code import app def dev_server(): app.run() if __name__ == &amp;#34;__main__&amp;#34;: from django.utils import autoreload autoreload.main(dev_server) http://blog.est.im/post/34342180038</description></item></channel></rss>