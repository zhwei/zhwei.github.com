---
layout: post
title: "Gotit多线程加速及缓存"
date: 2013-09-13 21:19
comments: true
tags: gotit 多线程
menu: true
---


## 问题来源

gotit一直正常运行，现在不是成绩查询的时间了，访问量也少了不少。趁着这段时间打算重构下网站代码，当初上线之后总是添加功能或者应对正方教务系统，现在的代码非常乱。还有就是，正方查询的页面加载很慢，主要是登录之前的`pre_login`操作， 需要先访问一次正方教务系统，获取初始化用户状态(此处保存的是一个对象, 下面称其为zf)和中文验证码图片。  

相对其他页面的响应来说， 这段时间是最长的， 粗略测试了下，其时间在0.6～1.5秒之间不等，多次刷新的时候需要等待的时间更长，并且有的时候正方系统会响应不及时，导致无法获取用户状态。

开始时，我打算将zf缓存到redis中，每一时刻都缓存若干个zf供用户使用，设置好过期时间，删除过期的zf，如果缓存的zf小于一定数目则进行获取，如此供用户使用，此时用户每次进行GET的时候仅从服务器本机获取数据而不用访问正方系统，一定会快很多。后来发现，并不是所有的对象都是能序列化(pickle)的。在《python标准库》中提到：

> 套接字、文件句柄、数据库链接以及其他运行时状态依然依赖操作系统或者其他进程的对象可能无法用一种有意义的方式保存。

需要缓存的zf对象就不能进行序列化，因为他依赖urllib2提供的opener，这样就不能使用redis进行缓存，只能将其缓存在内存中，比如保存在一个全局字典中，现在模拟登录的方法就是使用了一个字典保存用户get时获得的zf，用户post信息（学号、密码和验证码）后从字典中将zf读取出来，继续处理。


## 多线程加速

现在需要三个线程：

+ DaemonThread : 守护线程

  - 检测缓存字典中zf的数目
  - 如果小于某一特定数值时则创建缓存（即创建zf）
  - 如果大于该数目则等待

+ CheckThread: 过期处理

  - 检查缓存字典中的键值对是否过期
  - 过期则POP

+ MainThread : 调用上述线程

  - 多线程调用


(未完)
