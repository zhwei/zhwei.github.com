<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on zhwei's Blog</title><link>https://zhw.in/post/</link><description>Recent content in Posts on zhwei's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 12 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://zhw.in/post/index.xml" rel="self" type="application/rss+xml"/><item><title>《重来3》书摘</title><link>https://zhw.in/post/rework-book-excerpt/</link><pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate><guid>https://zhw.in/post/rework-book-excerpt/</guid><description>重来3：跳出疯狂的忙碌 贾森·弗里德 戴维·海涅迈尔·汉森 9个笔记
◆ 边走边摸索
+1s
要想把舵掌稳，那就在前行中及时做出微调，一千次也不怕，这肯定比一上来就猛打几次舵轮强得多。
◆ 信任犹如电池
当员工刚进公司时，这个电池的电量是50%。此后，你每跟他打一次交道，你们之间的这节信任电池就要么充电，要么耗电，具体取决于你是否能兑现承诺的事。
◆ 低处的果子未必摘得到
把一项不熟悉的任务比作长在低处的果子，基本上只能说明你对要做的事情一点儿都不了解。
◆ 不做薪酬谈判
我们许下承诺，万一有一天我们把公司卖掉了，我们就拿出收益的5%来分给现有的全体员工。不必追看股价，不必担心估值。
◆ 群聊的害处
“在少数情况下实时沟通，在大部分情况下不必”，以及“如果这件事很重要，那就慢慢来”。
◆ 逼死人的截止日期
固定的截止日期，可变的工作量
◆ 完成比完美更重要
完成比完美更重要
◆ 故意放弃
我们从第一天起，就拒绝了按人数收费的商业模式。这不是因为我们不喜欢钱，而是因为我们更加喜欢自由！</description></item><item><title>记账这件小事儿</title><link>https://zhw.in/post/bookkeeping/</link><pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate><guid>https://zhw.in/post/bookkeeping/</guid><description>从 3 月份开始精细化记账到现在刚满一个月，记录下个人体验和记账方式。
为什么开始记账 钱不知道花到哪里去了 对日常开销多少没概念，亲戚家人偶尔会问起 “你在 xx 每个月大概花多少钱？”，(⊙o⊙)… 一脸懵逼的回答 “几千块钱吧”。
买了好多 App，平日里经常收到 AppStore 等订阅平台的账单通知，每月（年）到底需要给这些东西付多少钱？
扫码、刷脸支付一点都不刺激，不知不觉付了很多钱，没了很多没用的东西，扔到家里放很久，然后出闲鱼。
几个月前决定停止使用信用卡，因为每到月末还信用卡时总会肉疼到怀疑人生，停用信用卡后，虽然没不再有还款时那么刺激的体验，但发现银行卡余额再也不涨了，偶尔还会跌 -_-，并没有真正解决问题。
强烈的购物欲 我是个很容易被种草的人，喜欢听好物推荐的播客，喜欢看新鲜工具的文章，喜欢买各种各样的小工具。陪老婆逛街，最喜欢溜达的是 miniso 这种杂物店，发现新奇的小玩意儿会很开心，然后搬回家。
无聊时偶尔会刷刷京东淘宝的推荐。
远程养了一只猫，本地养了一个娃、一个贤妻，给 Ta 们买东西时会很开心。
记账应该能稍微控制一下购物的欲望。
怎样记账 工具控又开始列用过的软件了！
之前用过 多多记账
最早使用的记账 App，支持纯文字或语音记账，自动识别分类，对懒人很友好。缺点是只能靠人工录入，并且只有移动端，记账效率低。
随手记
缺点和多多记账一样，支持多个账本，长期用来记一些低频事件的账务，比如理财的转账记录、娃收的红包等等。
效率控
用其中的【订阅管理】功能统计订阅的 App、付费服务等。
现在用的 MoneyWiz，UI 算不上精美，但很实用，单次记账操作要比多多、随手记麻烦很多，但有很多优点：
支持 CSV 导入导出
对一个数据洁癖患者来说，原始数据能掌握在自己手里的感觉非常棒，就像写文字时喜欢用 MarkDown 一样。能导出就意味着：我可以随时抛弃它迁移到任意平台，历史数据不会丢失。
CSV 导入也是一个非常关键的功能，并且它的导入功能也非常灵活，支持做列映射。MoneyWiz 支持从很多银行自动导入账单，但毫无悬念的是不支持国内银行，CSV 导入功能在一定程度上弥补了这个损失，我写了几个简单的脚本解析银行月账单生成 CSV 格式文本，然后导入 MoneyWiz，节省了很多人力录入的时间。
支持预定消费或收入
用来记录订阅费用再适合不过了，另外也可以为周期性的收入（工资等）设置预定。预定支持自动支付或者非自动支付，在记账过程中这两种机制能带来非常美妙的体验，既能覆盖无脑入账的场景，也能给记账者一些掌控感。
自动支付，可用在人民币自动扣费、苹果设备分期、房贷等金额固定、自动扣除的场景。 非自动支付，当遇到外币扣费时，经过人工确认下会更合适，因为汇率时刻都在变化，很难保证扣费时的汇率和记账的汇率完全一致。 截图自我的预定
自定义报表
内置了很多不同维度的报表，但最令我欣喜的是支持自定义报表（可能是程序员角色对自定义、可编程有超乎寻常的迷恋）
下面报表虽然看起来支持简单的消费类别柱状图，但制作时排除了几个固定支出类别和账户，因此我在记账时不用担心被某些固定/意外支出影响。
到目前的支出组成
预算</description></item><item><title>Postman 实现带 csrf_token 的表单登录</title><link>https://zhw.in/post/postman-login-with-csrftoken/</link><pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate><guid>https://zhw.in/post/postman-login-with-csrftoken/</guid><description>Postman 虽然自带了多种授权方式，但不同项目的登录方式千奇百怪，完全遵照 OAuth 等标准授权协议的项目简直是凤毛麟角。
下面使用 Postman 的 Pre-request Script 实现了 csrf_token 解析，然后与邮箱密码一起发起登录请求。
脚本中使用了多个环境变量，需要切换身份登陆时可以通过切换不同 Environment 实现。用到的环境变量如下：
Environments
APP_URL 应用的 base url，便于切换不同环境（local、staging 等），eg: https://app.test USER_EMAIL 登录使用的邮箱 USER_PASSWORD 登陆使用的密码 新建 Request，以下面是登录请求为例：
curl --location --request POST 'https://app.test/login' \ --form 'email=&amp;quot;user@example.com&amp;quot;' \ --form 'password=&amp;quot;123456&amp;quot;' \ --form '_csrf_token=&amp;quot;hmXaw7m2Mgyinr7yPHPgPbfVmtH4dOSwOUXykhC0&amp;quot;' 在 Pre-request Script 中发起 GET 请求解析 csrf token：
// 先清理 cookie (登陆状态) // 需要预先配置域名到 Whitelist Domains，否则无法使用 Script 清理 pm.cookies.jar().clear(pm.environment.get(&amp;#39;APP_URL&amp;#39;), (clearError) =&amp;gt; { if (clearError) { console.</description></item><item><title>虚拟组网工具推荐</title><link>https://zhw.in/post/virtual-networking/</link><pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate><guid>https://zhw.in/post/virtual-networking/</guid><description>引子 推荐虚拟组网工具前先说一下个人网络环境。
在前司工作时，由于一直是远程工作，几乎随时都要联通公司内网，前司的 VPN 用的深信服的 SSL VPN。Mac 端的客户端非常难用，几乎隔几小时就要断一次，于是写了个 AppleScript 自动重连脚本续了一段时间。但有个问题，手机上很难访问公司内网，且不说其手机客户端有多难用，深信服 VPN 限定了一个用户只能有一个设备在线，想在手机上测试时非常痛苦。
另外，一直使用 Surge 作为代理客户端，增强模式真的是非常强大，除了强大的规则、代理功能之外，日常用来抓包也非常方便。
于是有了个想法，能不能把公司的内网转发也交给 Surge 处理呢？
说干就干，在公有云申请了一台 Windows Server 主机作为 Gateway，之所以用 Windows 是因为深信服 VPN 的 Windows 客户端相对更稳定一些，然后在 WinServer 运行 VPN 客户端，又写了一个 AutoIT 脚本守护这个客户端，一旦断开自动重连。最后，通过 SS 暴露给 Surge 使用，非常完美！从此以后彻底摆脱了深信服的 VPN 客户端，手机端也可以非常顺滑的访问公司内网资源。
有了带公网 IP 的 Gateway 后，我又盯上了家里的 NAS ！这玩意怎样在保证安全的前提下载公网使用呢？
虚拟组网 本地组网相比大家都非常熟悉，一堆设备挂在交换机或者路由器下面，就可以组成一个简单的局域网，各设备直接可通过局域网 IP 访问。
与本地组网不同的是，虚拟组网设备之间没有通过网线连接，甚至不在一个机房、国家甚至地区。但通过 P2P 或者中转节点，实现了局域网的效果。
下面列一下从开始使用到目前为止遇到的组网工具机器优缺点。
ZeroTier https://www.zerotier.com
我目前用的工具，放在最开始并不意味着它是最好的，但它是最适合我的个人场景的。
优点
P2P 通信 支持自建 moon 节点，用于服务发现（已自建） 当无法建立 P2P 通信时，流量也会通过 moon 节点转发 国内运营商会限制 UDP 流量，甚至分配假的公网 IP，导致无法建立 P2P 链接 所以还是用自己的更放心 :) 有 Windows、NAS GUI 客户端，配对简单 有在线 Central 管理功能，强大又方便（相对于下面方案需要自己手写配置配置文件） 在线路由管理很强大 缺点</description></item><item><title>关于播客</title><link>https://zhw.in/post/podcast/</link><pubDate>Mon, 11 Jan 2021 00:00:00 +0000</pubDate><guid>https://zhw.in/post/podcast/</guid><description>引子 好久没写博客了，有点手痒，想了想就写一篇关于播客的吧。 从 18 年开始有了听播客的习惯，最早关注的播客是《津津乐道》。再早之前也曾听过几个节目，比如最近开始复更的《Teahour》早期关于工程师的一期，当时对播客这个概念很陌生，播客对我也没有多少吸引力。 再到后来一次开车赶路途中，心血来潮听了津津乐道有一期关于 ‘伪科学’ 的节目，突然感觉：咦，这玩意有点意思。
工具控 Podcast iOS 用户知道播客这个东西后，一般都会使用 Podcast App 听播客，但后来感觉这玩意体验很不好，其中最令人讨厌的地方是操作层级太深了，比如，我在发现新的播客后，会习惯性地翻一遍主播的历史节目，每次都要在多个 tab 里切好几遍才能找到历史节目列表，很令人抓狂。
Overcast 后来从津津乐道的节目介绍中知道了原来还有泛用性播客客户端这东西，基于 rss 订阅，这玩意儿对程序员来说熟悉的很呀。搜罗了一下找到了 Overcast 这个 App，功能简单，页面粗犷，但它有两个特性我非常喜欢：
Smart Speed，自动压缩没有声音的时长 Voice Boost，放大主播声音 尤其是后者，早期很多播客的制作品质并不高，主播声音经常被背景音或其他杂音盖过。 用了一年后，甚至订阅了 Premium 支持它，最终还是放弃了，因为真的是太粗犷了，播放列表和订阅列表放在同一个页面，订阅多了之后，只能靠搜索，每次使用都影响心情。
然后开始寻找其他替代 App
又尝试了一下 Podcast App，然后果断放弃 Castro，Overcast 免费提供的两个特性，在 Castro 里是需要付费的，感觉吃相不好看，放弃 最终试用了 Pocket Casts，很不错 Pocket Casts 使用 Overcast 之前也发现了这个 App，但在国区貌似无法安装，当时不太想折腾也就跳过了，再次尝试发现真香：
首页订阅列表，每行四个播客 icon，查找播客很方便 Filter 支持更多筛选条件，左右滑动加到播放列表顶部/底部，每次操作都令人愉悦 Overcast 提供的两个功能也都在 公司产品，迭代频率较高 统计功能，满足自己小小的虚荣心 果断订阅 Plus 支持了，截止目前，在 Pocket Casts 收听总时长已经接近八天了。</description></item><item><title>Docker Jenkins Run Tests in Docker</title><link>https://zhw.in/post/docker-jenkins-run-tests-in-docker/</link><pubDate>Mon, 04 Dec 2017 00:00:00 +0000</pubDate><guid>https://zhw.in/post/docker-jenkins-run-tests-in-docker/</guid><description>起因 团队使用 Jenkins CI 来对 Pull Request 进行上线前的检查，例如：编码风格、静态分析、测试等。
最近遇到了测试时的并发问题，由于 Jenkins 需要在 PR 更新时重新检查，每完整测试一次需要 10 到 15 分钟，同时有很多开发者提交 PR 时，就会导致长时间无意义的等待，有此希望能提高 Jenkins 的并发测试能力。
选择方案 先介绍下项目测试时依赖的环境：
- PHP - Redis - MySQL - ElasticSearch 多个 PR 测试进程之间，ES、Redis 是可以共享的，但 MySQL 不可以，其中考虑的方案是考虑能否通过改变项目中的数据库名称从而共享同一台 MySQL Server ，但实际调试中发现除去 ORM 能够简单变更数据库外，还是有很多场景中的数据库名称是写死在代码里面的，所以这条方案宣告放弃。
如标题所说，我们的 Jenkins 是运行在 docker 中的，那测试是不是也可以在 docker 中运行呢，所有依赖环境、软件包，全部通过 docker 打包整理，最终 Jenkins 在发起测试时需要调用的是一个 docker 命令，那么问题来了，怎样让 Jenkins 调用 docker ？想到的有以下两个思路：
Jenkins 中完整安装 docker ，关注点：
需要重新 build jenkins image，调试会很麻烦 性能会不会有问题？docker 中运行了一个 docker ，然后在这个 docker 里运行了四个实例 网络会不会有问题？172 这个网段会不会混乱（还是调试问题） Jenkins 中调用宿主机的 docker ，关注点：</description></item><item><title>PHPCon China Laravel Lego 分享的 Slide</title><link>https://zhw.in/post/phpcon-china-laravel-lego-%E5%88%86%E4%BA%AB%E7%9A%84-slide/</link><pubDate>Wed, 21 Jun 2017 00:00:00 +0000</pubDate><guid>https://zhw.in/post/phpcon-china-laravel-lego-%E5%88%86%E4%BA%AB%E7%9A%84-slide/</guid><description>GitHub：ThinkDevelopers/PHPConChina, PDF file link</description></item><item><title>HTTP请求方式注解</title><link>https://zhw.in/post/http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B3%A8%E8%A7%A3/</link><pubDate>Mon, 16 Jun 2014 00:00:00 +0000</pubDate><guid>https://zhw.in/post/http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B3%A8%E8%A7%A3/</guid><description>被问到了HTTP常见的几个方法，也有些迷惑的地方，整理如下。
GET GET是http的默认请求方式， 一般用来获取数据， 传输的数据经过url编码后放在路径?之后， 多个键值对通过&amp;amp;连接， 另外get的传输长度一般不推荐超过255个字节。
GET方法一般被视为安全方法， 因为它仅用来获取数据而不会对服务器有其他改动。
安全方法
像HEAD、GET、OPTIONS 和 TRACE这几种http方法是被认为是“安全的”， 这意味着它们只会进行获取数据而不会修改服务器的状态， 换句话说，它们不会产生负面影响， 当然除了常见的无害操作，比如记录日志、创建缓存或者创建其他统计信息。
正相反， 像POST、PUT、DELETE 和 PATCH 等方法是有可能产生副作用。网络爬虫等一般不会使用这些方式(笔者注:搜索引擎的暗网抓取可能会使用这些方法)。
尽管GET方法是一般被视为“安全的”，但如果在实际使用中没有做任何设置，比如可以无限制的抓取等情况， 也会导致一些不可预料的问题，比如web缓存或者搜索引擎问题。
POST POST一般用来上传文件或者提交一个完整的web表单。
这是Chrome中查看到的POST内容
实际数据是这样的
user=554101&amp;amp;user_code=eNWyXdrrTpC6hoSvzPHBYKLljGkcDw79QsWtNeMu&amp;amp;attachment=0&amp;amp;code_brush=&amp;amp;code_snippet=&amp;amp;msg=test 浏览器中提交表单时，这里与get类似，每个键值对都是通过&amp;amp;分割, 其他非字母数字会进行url转码。
为什么一些请求会使用POST提交数据?
GET请求数据都可以在URL中看到 GET提交的数据都会有长度限制 一般规范，POST用来修改数据，GET用来获取数据 GET请求请提交的数据放置在HTTP请求协议头中，而POST提交的数据则放在实体数据中 其他请求方式 HEAD 获取某个URI响应头信息，基本与GET相同但是不返回响应主体。
PUT 通过提供的URI获取到特定的内容主体，如果存在则修改内容，如果不存在则创建。
DELETE 通过URI删除指定内容
TRACE 返回接受到的请求，用来查看数据经过中间服务器时发生了哪些变动
OPTIONS 返回给定URL支持的所有HTTP方法
CONNECT 要求使用SSL和TLS进行TCP通信
PATCH 请求修改局部数据
参考链接 http://en.wikipedia.org/wiki/POST_(HTTP) http://en.wikipedia.org/wiki/GET_(HTTP)</description></item><item><title>Web敏捷开发</title><link>https://zhw.in/post/web%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/</link><pubDate>Fri, 13 Jun 2014 00:00:00 +0000</pubDate><guid>https://zhw.in/post/web%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/</guid><description>AGILE WEB DEVELOPMENT WITH DJANGO</description></item><item><title>django从一个form保存到两个model</title><link>https://zhw.in/post/django%E4%BB%8E%E4%B8%80%E4%B8%AAform%E4%BF%9D%E5%AD%98%E5%88%B0%E4%B8%A4%E4%B8%AAmodel/</link><pubDate>Wed, 19 Feb 2014 00:00:00 +0000</pubDate><guid>https://zhw.in/post/django%E4%BB%8E%E4%B8%80%E4%B8%AAform%E4%BF%9D%E5%AD%98%E5%88%B0%E4%B8%A4%E4%B8%AAmodel/</guid><description>from django.forms.models import model_to_dict, fields_for_model class UserDetailsForm(ModelForm): def __init__(self, instance=None, *args, **kwargs): _fields = (&amp;#39;first_name&amp;#39;, &amp;#39;last_name&amp;#39;, &amp;#39;email&amp;#39;,) _initial = kwargs.pop(&amp;#39;initial&amp;#39;) # pop出initial参数 _initial = model_to_dict(instance.user, _fields) if instance is not None else {} super(UserDetailsForm, self).__init__(initial=_initial, instance=instance, *args, **kwargs) self.fields.update(fields_for_model(User, _fields)) class Meta: model = UserDetails exclude = (&amp;#39;user&amp;#39;,) def save(self, *args, **kwargs): u = self.instance.user u.first_name = self.cleaned_data[&amp;#39;first_name&amp;#39;] u.last_name = self.cleaned_data[&amp;#39;last_name&amp;#39;] u.email = self.cleaned_data[&amp;#39;email&amp;#39;] u.save() profile = super(UserDetailsForm, self).save(*args,**kwargs) return profile 取自 http://stackoverflow.</description></item><item><title>Gotit改进与待做</title><link>https://zhw.in/post/gotit%E6%94%B9%E8%BF%9B%E4%B8%8E%E5%BE%85%E5%81%9A/</link><pubDate>Tue, 18 Feb 2014 00:00:00 +0000</pubDate><guid>https://zhw.in/post/gotit%E6%94%B9%E8%BF%9B%E4%B8%8E%E5%BE%85%E5%81%9A/</guid><description>Gotit 近段时间的改进和以后一段时间内的更新计划，挖坑的时间到了，准备跳票。
改进 使用requests替代urllib requests的确是HTTP library human， 自动处理文字编码、灵活的cookie操作，的确赏心悦目！并且它的cookie支持pickle，因此可以直接将每次的请求缓存到redis，相对于以前缓存整个对象到内存中的全局字典，不得不说更稳定灵活了好多！
重写正方查询的类与缓存机制 原来的正方类是与自己写的缓存紧密耦合的，旧的缓存机制使用内存全局字典作为存放地点，创建缓存与缓存过期判断都是由多个线程判断，并且某些线程在特定条件下还会创建更多子线程，到了最后虽然能正常工作但不得不说成了像shi一样的代码。现在所有缓存都放在redis中，缓存的过期时间完全由redis控制，只在用户每次查询操作时重置缓存时间就可以了。
完善异常处理 一直没有想到正方教务系统竟然有那么多的报错提醒，由于其多数请求异常都是弹窗提醒，所以可以通过特定的正则表达式匹配出多数的弹窗提醒，在每次页面请求后都会检测是否有弹窗警告，主要是登录时候的报错，新生没有更改初始密码是不能进行查询的。
彻底放弃了bs3分支 bs3分支就是上面说的时候大量线程进行提前缓存，当时还写了一篇博客，后来发现，出现的问题远大于解决的问题，并且大量线程在正方系统发生宕机或者其他异常时候会一直阻塞，也一直找不到合适的解决方案，痛苦了好久后决定放弃该分支，继续升级维护2.0-stable分支。但是已经将bs3中的Bootstrap3界面迁移到了2.0分支。
待做 优化缓存 有些时候用户查询到的内容是没有发生变化的，打算将用户查询到的内容缓存到redis中，并且某些时候（例如过年前后）正方教务系统可能会直接停止，在这种情况下可以通过使用长期缓存。 另外可以在用户查询单个内容时，为用户将其他内容缓存。（例如当张三在查询当前学期成绩时，返回成绩后继续将他的课表、绩点、考试时间等内容缓存，如果他继续查询其他内容，响应速度将会大量提高，不再受正方、网络延时的影响。
优化移动端页面 移动端的浏览量与PC端的浏览量相差无几， 移动端需要优化的主要是查询结果页面的表格，前段时间迁移bootstrap3后使用了bs的响应式表格，但是在uc浏览器上无法使用，所以又添加了一个表格调整的按钮切换回旧的样式。这也是一个急需解决的问题。
网站后台 话说到现在为止gotit是没有网站后台的，所有的配置都是写在配置文件中，好吧，话说主要是想偷懒。现在后台已经在开发之中，包括每个页面的公告、网站公告、捐献者等内容，当然还有网站的各种日志，也不希望每次都要远程到服务器上才能看到到底发生了什么。 还有一个目的就是积累用户啦，主要推广方法还是靠下一个内容了。
成绩更新提醒 成绩提醒，就是在成绩更新后及时通知给相应的用户，这里只要保留cookie就行了，不过由于神一样的正方教务系统在大量请求下极其脆弱，每一次宕机cookie就失效了，再由于中文验证码的存在，还没有完善的解决方案，所以算是一个超级Beta内容了，将来只会对捐献者开放这项功能。</description></item><item><title>家里的第一场雪</title><link>https://zhw.in/post/%E5%AE%B6%E9%87%8C%E7%9A%84%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%9B%AA/</link><pubDate>Sun, 09 Feb 2014 00:00:00 +0000</pubDate><guid>https://zhw.in/post/%E5%AE%B6%E9%87%8C%E7%9A%84%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%9B%AA/</guid><description/></item><item><title>家里的第一场雪</title><link>https://zhw.in/post/%E5%AE%B6%E9%87%8C%E7%9A%84%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%9B%AA/</link><pubDate>Sun, 09 Feb 2014 00:00:00 +0000</pubDate><guid>https://zhw.in/post/%E5%AE%B6%E9%87%8C%E7%9A%84%E7%AC%AC%E4%B8%80%E5%9C%BA%E9%9B%AA/</guid><description/></item><item><title>Supervisor笔记</title><link>https://zhw.in/post/supervisor%E7%AC%94%E8%AE%B0/</link><pubDate>Sat, 14 Dec 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/supervisor%E7%AC%94%E8%AE%B0/</guid><description>Supervisor是一个C/S系统，用来监控和控制多个服务进程，只限于UNIX-like操作系统。
官方文档 http://supervisord.org/
安装 setuptools
pip install supervisor # or easy_install supervisor 初始使用 创建配置文件 需要以root身份执行
echo_supervisord_conf &amp;gt; /etc/supervisord.conf 调整配置文件 增加web管理界面 取消配置文件中的下列行，并按需配置用户名密码
[inet_http_server] port=*:9001 username=your_username ; (default is no username (open server)) password=your_password ; (default is no password (open server)) 添加服务 配置文件详解
[supervisorctl] serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL for a unix socket ;serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket ;username=chris ; should be same as http_username if set ;password=123 ; should be same as http_password if set ;prompt=mysupervisor ; cmd line prompt (default &amp;#34;supervisor&amp;#34;) ;history_file=~/.</description></item><item><title>lvm笔记</title><link>https://zhw.in/post/lvm%E7%AC%94%E8%AE%B0/</link><pubDate>Fri, 13 Dec 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/lvm%E7%AC%94%E8%AE%B0/</guid><description>介绍 LVM Logical Volume Manager
LVM是Linux环境下对磁盘分区进行管理的一种机制，LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。
能解决哪些问题 在线通过增加或减少物理卷组改变逻辑卷组的大小 在小型系统上，比如个人电脑，不必在安装系统的时候费脑筋估算分区的大小，lvm上以后可以按需求轻易调整分区的大小。 能够对逻辑分区实现一致性备份 可以在多个物理卷或者整个硬盘上创建单个分区，有点像RAID 0, 但更像JBOD, 允许动态调整卷的大小。 创建LVM 如果要在/dev/sda3, /dev/sda4, /dev/sda5上创建lvm
创建物理卷
pvcreate /dev/sda{3..5} 创建为卷组
vgcreate test0 /dev/sda{3..5} 在卷组test0上创建10G的逻辑卷 lv_0
lvcreate -L 10G -n lv_0 test0 创建文件系统并挂载
mkfs.ext4 /dev/test0/lv_0 扩容 需求： 将物理卷/dev/sda6 加入lvm并扩大为20G
创建物理卷
pvcreate /dev/sda6 添加到卷组test0
vgextend test0 /dev/sda6 扩展逻辑卷, 扩展到20G
lvextend -L 20G /dev/test0/lv_0 使增加的容量生效
resize2fs /dev/test0/lv_0 搞定
减容 需求： 将逻辑卷减小成10G</description></item><item><title>PyConChina上海场现场</title><link>https://zhw.in/post/pyconchina%E4%B8%8A%E6%B5%B7%E5%9C%BA%E7%8E%B0%E5%9C%BA/</link><pubDate>Sun, 08 Dec 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/pyconchina%E4%B8%8A%E6%B5%B7%E5%9C%BA%E7%8E%B0%E5%9C%BA/</guid><description>开始前 帽子
s t</description></item><item><title>Pyinstaller打包Python写的windows服务-记录</title><link>https://zhw.in/post/pyinstaller%E6%89%93%E5%8C%85python%E5%86%99%E7%9A%84windows%E6%9C%8D%E5%8A%A1-%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 10 Nov 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/pyinstaller%E6%89%93%E5%8C%85python%E5%86%99%E7%9A%84windows%E6%9C%8D%E5%8A%A1-%E8%AE%B0%E5%BD%95/</guid><description>由来 最近在写一个服务器监控平台，python开发，前端标准bootstrap，后端Bottle, 数据库mongodb，要写服务器监控肯定少不了客户端了，客户端主要用到了XMLRPCServer, 服务端与客户端通过xml通信，这个在python的标准库里，还是可以信赖的，并且支持http验证，此处不赘言，以后再讲。linux上的客户端很好搞，因为linux自带python解释器，不管版本如何，使用起来还是很好改的， 最头疼的是window下的客户端，以前很少在win下做开发，python环境也是随意搭了一下，正使用的时候还是各种DT。。。
花了一段时间写了一个win下的python程序，不过依赖很多，包括pywin32、wmi，并且python的安装还需要改注册表，作为一个监控，如果还需要在服务器上安装python环境等东西有点得不偿失了。找到了pyinstaller和py2exe，能够将python程序打包成可执行的exe文件，复制到其他机器上可以直接执行，下面进入正题！
各种环境安装 安装pywin32、wmi弹框 Python version 2.7 required, which was not found in the registry 在注册表中找不到python，使用下面的一个脚本放在c盘根目录执行下就可以, 见Link
程序 # SmallestService.py # # A sample demonstrating the smallest possible service written in Python. import win32serviceutil import win32service import win32event class SmallestPythonService(win32serviceutil.ServiceFramework): _svc_name_ = &amp;#34;SmallestPythonService&amp;#34; _svc_display_name_ = &amp;#34;The smallest possible Python Service&amp;#34; def __init__(self, args): win32serviceutil.ServiceFramework.__init__(self, args) # Create an event which we will use to wait on.</description></item><item><title>windows service example using pyInstaller</title><link>https://zhw.in/post/windows-service-example-using-pyinstaller/</link><pubDate>Sat, 09 Nov 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/windows-service-example-using-pyinstaller/</guid><description>用python写的windows服务，支持pyinstaller打包。 # Usage: # service.exe install # service.exe start # service.exe stop # service.exe remove # you can see output of this program running python site-packages win32libwin32traceutil import win32service import win32serviceutil import win32event import win32evtlogutil import win32traceutil import servicemanager import winerror import time import sys import os class aservice(win32serviceutil.ServiceFramework): _svc_name_ = &amp;#34;aservice&amp;#34; _svc_display_name_ = &amp;#34;aservice - It Does nothing&amp;#34; _svc_deps_ = [&amp;#34;EventLog&amp;#34;] def __init__(self,args): win32serviceutil.ServiceFramework.__init__(self,args) self.hWaitStop=win32event.CreateEvent(None, 0, 0, None) self.</description></item><item><title>pySerial -- Python的串口通讯模块</title><link>https://zhw.in/post/pyserial-python%E7%9A%84%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%9D%97/</link><pubDate>Sat, 26 Oct 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/pyserial-python%E7%9A%84%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%9D%97/</guid><description>介绍 pySerial
封装了串口通讯模块，支持Linux、Windows、BSD(可能支持所有支持POSIX的操作系统)，支持Jython(Java)和IconPython(.NET and Mono).
首页 http://pyserial.sf.net/
特性 所有平台使用同样的类接口 端口号默认从0开始，程序中不需要知道端口名称 像文件读写一样的API，read、write（readline等也受支持） 所有程序全由Python完成，除了标准库外不依赖其他包，除了pywin32(windows)、JavaComm(Jython). POSIX(Linux, BSD) 只依赖Python标准库。 依赖环境 Python2.2或更新版本 windows 上的 pywin32扩展 Java/Jython上的 &amp;ldquo;Java Communications&amp;rdquo; (JavaComm)或者兼容包 安装 pip/easy_install
pip install pyserial easy_install pyserial windows
下载地址 ： http://sourceforge.net/project/showfiles.php?group_id=46487
快速上手 Open port 0 at &amp;ldquo;9600,8,N,1&amp;rdquo;, no timeout
&amp;gt;&amp;gt;&amp;gt; import serial &amp;gt;&amp;gt;&amp;gt; ser = serial.Serial(0) # open first serial port &amp;gt;&amp;gt;&amp;gt; print ser.portstr # check which port was really used &amp;gt;&amp;gt;&amp;gt; ser.</description></item><item><title>使用django框架的reloader重载WSGI app</title><link>https://zhw.in/post/%E4%BD%BF%E7%94%A8django%E6%A1%86%E6%9E%B6%E7%9A%84reloader%E9%87%8D%E8%BD%BDwsgi-app/</link><pubDate>Sat, 28 Sep 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/%E4%BD%BF%E7%94%A8django%E6%A1%86%E6%9E%B6%E7%9A%84reloader%E9%87%8D%E8%BD%BDwsgi-app/</guid><description>使用django框架的autoreload在网站程序代码改动时重载应用。
一般来说这种方法适用与所有的wsgi app, 这里只说下web.py和bottle
bottle
from bottle import run, Bottle app = Bottle() def dev_server(): run(app, host=&amp;#39;0.0.0.0&amp;#39;, port=8080, debug=True) if &amp;#39;__main__&amp;#39; == __name__: from django.utils import autoreload autoreload.main(dev_server) web.py
from code import app def dev_server(): app.run() if __name__ == &amp;#34;__main__&amp;#34;: from django.utils import autoreload autoreload.main(dev_server) http://blog.est.im/post/34342180038</description></item><item><title>Gotit多线程加速及缓存</title><link>https://zhw.in/post/gotit%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%80%9F%E5%8F%8A%E7%BC%93%E5%AD%98/</link><pubDate>Fri, 13 Sep 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/gotit%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%80%9F%E5%8F%8A%E7%BC%93%E5%AD%98/</guid><description>问题来源 gotit一直正常运行，现在不是成绩查询的时间了，访问量也少了不少。趁着这段时间打算重构下网站代码，当初上线之后总是添加功能或者应对正方教务系统，现在的代码非常乱。还有就是，正方查询的页面加载很慢，主要是登录之前的pre_login操作， 需要先访问一次正方教务系统，获取初始化用户状态(此处保存的是一个对象, 下面称其为zf)和中文验证码图片。
相对其他页面的响应来说， 这段时间是最长的， 粗略测试了下，其时间在0.6～1.5秒之间不等，多次刷新的时候需要等待的时间更长，并且有的时候正方系统会响应不及时，导致无法获取用户状态。
开始时，我打算将zf缓存到redis中，每一时刻都缓存若干个zf供用户使用，设置好过期时间，删除过期的zf，如果缓存的zf小于一定数目则进行获取，如此供用户使用，此时用户每次进行GET的时候仅从服务器本机获取数据而不用访问正方系统，一定会快很多。后来发现，并不是所有的对象都是能序列化(pickle)的。在《python标准库》中提到：
套接字、文件句柄、数据库链接以及其他运行时状态依然依赖操作系统或者其他进程的对象可能无法用一种有意义的方式保存。
需要缓存的zf对象就不能进行序列化，因为他依赖urllib2提供的opener，这样就不能使用redis进行缓存，只能将其缓存在内存中，比如保存在一个全局字典中，现在模拟登录的方法就是使用了一个字典保存用户get时获得的zf，用户post信息（学号、密码和验证码）后从字典中将zf读取出来，继续处理。
多线程加速 开始 全部操作需要四个线程： DaemonThread(D) : 守护线程
检测缓存字典中zf的数目 如果小于某一特定数值时则创建缓存（即创建zf） 如果大于该数目则等待 CreateThread(CR) : 创建缓存进程
守护线程的子线程 缓存不足的时候守护线程调用该线程创建缓存 CheckThread(CH) : 过期处理
检查缓存字典中的键值对是否过期 过期则POP MainThread(M) : 调用上述线程
多线程调用 all_clients: 缓存没有使用过的zf
保存缓存的字典 结构： time_md5 -&amp;gt; (zf, viewstate, timeStart ) used_clients: 经过get操作的zf
用户进行get操作时，使用的键将从前者中pop到这个字典中，供后来的POST操作时模拟登录使用 结构： time_md5 -&amp;gt; (zf, viewstate, timeStart ) login_succeed: 登录成功的zf</description></item><item><title>django相关笔记</title><link>https://zhw.in/post/django%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</link><pubDate>Sun, 04 Aug 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/django%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</guid><description>权限判断的装饰符 判断用户是否staff is_staff isn&amp;rsquo;t a permission so instead of permission_required you could use:
@user_passes_test(lambda u: u.is_staff) #或者 from django.contrib.admin.views.decorators import staff_member_required @staff_member_required link
如果已经登陆则跳转 适用于方法 def ver_not_login(func): def ver(*args): request = args[0] if request.user.is_authenticated(): return HttpResponseRedirect(reverse_lazy(&amp;#39;index&amp;#39;)) else: return func(request) return ver 使用 @ver_not_login def register(request): pass 适用于url def ver_not_login_with_template(func): def ver(*args, **kwargs): request = args[0] template_name = kwargs[&amp;#39;template_name&amp;#39;] if request.user.is_authenticated(): return HttpResponseRedirect(reverse_lazy(&amp;#39;index&amp;#39;)) else: return func(request, template_name) return ver 使用 url(r&amp;#39;^$&amp;#39;, ver_not_login_with_template(login), {&amp;#39;template_name&amp;#39;:&amp;#39;login.</description></item><item><title>Gotit从零开始</title><link>https://zhw.in/post/gotit%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</link><pubDate>Wed, 31 Jul 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/gotit%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/</guid><description>Gotit gotit开始时叫做正方教务系统查询工具, 仅用来帮助校外同学们查询本学期的成绩. gotit的名字只来源于我偶然买到的这个域名gotit.aisa, 当初.asia域名首年十八元促销, 就买到了这个. Gotit维护至今, 一直没有好好总结一下, 期间停停落落, 真的体会到了做产品的艰难, 出状况的时间不是自己说了算的, 使用人数多的时候每一秒都有十几个人同时访问, 每一个小小的失误, 都会给很多用户造成极大的困扰.
2013-01-09至2013-07-31
最初方法 使用urllib2模拟登录,然后使用BeaufitualSoup解析出所需的表格内容. 登录难点是url中有一段随机字符串,需要先将其匹配出来获得base_url, 一开始时是每一次登录都匹配一次该随机字符串,也就是说查询一次成绩程序要访问两次正方教务系统, 现在使用了马伟伟同学写的cache模块,每500秒获取一次该字符串,提高了成绩查询速度.另一个就是模拟登录时的post内容中有一个VIEWSTATE值, 类似与csrf_token吧, 登录时需要先抓取该值然后post.
test 部署相关 web.py 话说第一次上线比较急, 是直接通过web.py直接跑的, 不过也没怎么有压力, 估计是当初PV太低了
apache + mod_wsgi 这才算是第一次部署吧, 通过apache和mod_wsgi跑的web.py, 不过由于服务器上没有公网IP, 所以外面又加了一个nginx反向代理
详见: http://zhwei.42qu.com/14334743#h21
apache + gunicorn 话说我是不太喜欢用apache的, 因为每次重启服务时还需要重启下apache, 太蛋疼了, 不过机器上的nginx是当初lnmp一键安装包里的, 很难用, 只能用自己装的apache了, gunicorn更pythoner点, 另外支持多线程.
详见http://zhwei.42qu.com/14840780
nginx + gunicorn 现在用的, 换了一台服务器, 配置好些, 原来的做备份用了.
中文验证码 正方教务系统从原来的数字验证码到现在的中文验证码，尝试过验证码识别， 但是都不怎么理想，所以选择了让用户自己识别验证码，我们只模拟登陆。这样需要满足几个条件。
首先，成功获取验证码并保存为图片，其中图片命名遇到了问题，起初选择了使用随机整型数字命名，由于程序中的随机都是伪随机， 重合率很高！后来选择了使用时间的MD5值，一直沿用到现在作为用户的唯一识别码，使time.time()获得的时间精确到0.001秒，以现在的用户访问量遇到在同一0.001秒同时访问几乎是不可能的，并且事实也是如此。
用户需要在页面上直接输入学号、密码和验证码， 这就需要我们在用户第一次访问时就为其抓取下验证码供其识别，用户填写后由后台使用用户的数据进行模拟登陆从而抓取下成绩内容或者其他信息。而此处的难点是：怎样保证用户识别的验证码和他应该提交的验证码是同一个。因为正方系统还为每一个页面状态提供了一个VIEWSTATE参数，每次post都需要提供该参数。我一开始的想法是能够解析出每次抓取时的COOKIE不过后来想通了，由于每次都是在服务端抓取， 每次的COOKIE都是一样的，而每次的VIEWSTATE却是不一样的，所以这个方法被否定了。</description></item><item><title>本站用的管理工具</title><link>https://zhw.in/post/%E6%9C%AC%E7%AB%99%E7%94%A8%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link><pubDate>Tue, 18 Jun 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/%E6%9C%AC%E7%AB%99%E7%94%A8%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid><description>脚本可见 https://gist.github.com/zhwei/5613474
字典排序 line.118 dict1 = sorted(dict1.iteritems(), key=lambda k_v: (k_v[1], k_v[0]), reverse=True) # 字典按值排序, 生成元组列表 通过.iteritems()方法将字典转化成元组列表, 然后按元组的第二元素进行排序.
文章查找 line.128 将博客文件读入列表
对每一元素pop()使用find()方法查找关键词, 如果找到则将其插入列表首部, 循环一个列表长度后剩下的元素均是包含关键词的
for key in keys: i = 0 leng = len(artlist) while i &amp;lt; leng: d = artlist.pop() if d.find(key) != -1: artlist.insert(0, d) else: pass i = i + 1 然后可以再将处理后的文章列表作文参数传入, 再次匹配
操作git line.177 每次敲git命令也是挺麻烦的, 做了一个全自动的, 除了需要自己写 commit message
需要安装sh模块
def git(argv): &amp;#34;&amp;#34;&amp;#34; 将修改提交到git仓库 &amp;#34;&amp;#34;&amp;#34; try: import sh git = sh.</description></item><item><title>响应式页面设计</title><link>https://zhw.in/post/%E5%93%8D%E5%BA%94%E5%BC%8F%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/</link><pubDate>Sun, 16 Jun 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/%E5%93%8D%E5%BA%94%E5%BC%8F%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/</guid><description>要交web基础作业了, 一直没想出做什么页面, 想起自己的博客没有一个aboutme页面, 又想学一下响应式布局, 所以, 如你所见: aboutme
要针对不同的终端写不同的 css
这是 bootstrap 的分辨率区间划分
/* 大屏幕 */ @media (min-width: 1200px) { ... } /* 平板电脑和小屏电脑之间的分辨率 */ @media (min-width: 768px) and (max-width: 979px) { ... } /* 横向放置的手机和竖向放置的平板之间的分辨率 */ @media (max-width: 767px) { ... } /* 横向放置的手机及分辨率更小的设备 */ @media (max-width: 480px) { ... } 首先要在 head 里面加上 &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt;
然后在上面大括号中写不同分辨率的 css 样式就可以了
这是我的
/* 大屏幕 */ @media (min-width: 1200px) { .. } /* 横向放置的手机及分辨率更小的设备 */ @media (max-width: 480px) { /* 横向放置的手机和竖向放置的平板之间的分辨率 */ @media (min-width: 481px) and (max-width: 767px) { /* 小显示屏与横向平板之间的分辨率 */ @media (min-width: 768px) and (max-width: 979px) { /* 大屏小屏之间的分辨率 */ @media (min-width: 980px) and (max-width: 1199px) { 在某一分辨率区间的css时, 我的做法是直接将网页内容宽度直接定义为分辨率区间的最小值:</description></item><item><title>这就是搜索引擎 整理</title><link>https://zhw.in/post/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-%E6%95%B4%E7%90%86/</link><pubDate>Sat, 15 Jun 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/%E8%BF%99%E5%B0%B1%E6%98%AF%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E-%E6%95%B4%E7%90%86/</guid><description>网络爬虫 抓取策略
宽度优先 非完全pagerank opic策略(cash) 大站优先 更新策略
历史参考(泊松建模) 用户体验 聚类抽样 暗网抓取
分布式爬虫
主从式 url 对等式 (哈希取模 \ 一致性哈希 ) 搜索引擎索引 基础 单词-文档 倒排 单词字典 哈希加链表 树形结构 倒排列表 单词 &amp;ndash;&amp;gt; 倒排列表
建立列表 两遍 排序 单词id -&amp;gt; 文档ID -&amp;gt; 频率 归并 1 2 5 6 1 2 3 4
索引更新 完全重建 再合并 原地更新 混合策略 查询 一次一文档 一次单词 跳跃指针 `&amp;lt;5 Pos1&amp;gt; 5,1 2,1 5,2 &amp;lt;13 Pos2&amp;gt; 13,1 2,1 5,2</description></item><item><title>51最小开发板使用记录及virtualbox相关</title><link>https://zhw.in/post/51%E6%9C%80%E5%B0%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E5%8F%8Avirtualbox%E7%9B%B8%E5%85%B3/</link><pubDate>Mon, 10 Jun 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/51%E6%9C%80%E5%B0%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%E5%8F%8Avirtualbox%E7%9B%B8%E5%85%B3/</guid><description>最近对51开发板感兴趣, 用ma6174的51小板搞了下.
不过上来就卡住了, 由于笔记本双系统 ubuntu+win8, 在win8下死活装不上 usb转串口的驱动程序, 只能考虑使用虚拟机. 由于使用的主系统是ubuntu, 所以选择在ubuntn中的virtualbox中安装xp.
xp安装不讲
usb映射 最需要的虚拟机的一个功能是usb映射, 系统中的vbox是通过ubuntu源安装的, 装好系统后google了好久都没有把usb映射搞好, 在官方论坛中找到了原因, ** ubuntu源安装的不支持usb映射 **&amp;hellip;
官网下载安装好后, 运行提示没有权限控制usb子系统, 需要将用户添加到vboxusers用户组.
&amp;quot;FAILED TO ACCESS THE USB SUBSYSTEM.....
执行: sudo usermod -a -G vboxusers youruser
建议注销一下
-a 参数是将你的用户添加到新的用户组而不将你从原来的用户组中删除.
现在已经能够进行usb映射了,如果是笔记本的话还能够自动识别内置摄像头.
usb
STC ISP 握手失败 提示信息
Chinese:正在尝试与 MCU/单片机 握手连接 ... Chinese:连接失败，请尝试以下操作： 1.在单片机停电状态下，点下载按钮，再给单片机上电 ... 仍在连接中, 请给 MCU 上电... MCU Type is: STC89C52RC MCU Firmware Version: 4.3C Chinese:MCU 固件版本号: 4.3C Double speed / 双倍速: 12T/单倍速 振荡放大器增益: full gain 下次下载时 P1.</description></item><item><title>[翻译]A Guide to Python's Magic Methods</title><link>https://zhw.in/post/%E7%BF%BB%E8%AF%91a-guide-to-pythons-magic-methods/</link><pubDate>Tue, 21 May 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/%E7%BF%BB%E8%AF%91a-guide-to-pythons-magic-methods/</guid><description>原文作者:Rafe Kettler
原文链接: A Guide to Python&amp;rsquo;s Magic Methods
Copyright © 2012 Rafe Kettler
Version 1.17
本文档的英文pdf版本在pdf或者Github. 我在这里建了一个repo, 所有的issues可以在那里报告, 当然也可是是评论, 更可以是赞助!
内容列表:
介绍 构造和初始化 在任意类中使用运算符 - 比较 magic methods - 数值 magic methods 介绍 这篇方法引导总结了几个月来的博客文章. 它的标题是 magic methods.
什么事 magic methods? 它是面向对象的python中的所有东西. 它们是你能够自己向类中定义的特殊方法, 能够给你的类带来魔法般的效果! 它们以__开头以__结尾(eg: __init__或者__lt__). 它们的文档也比所期望的要少得多. python魔法方法总是出现在python文档的相同部分, 但是总是松散的, 并且很难在其中找到响应的案例, 当然也有可能是故意的, 所有的魔法方法在_语言参考 (language reference)_都有详细地列了出来, 附加还有令人厌烦的语法说明等等.
所以呢, 为了修复我所感受到的python文档的不完美之处, 我着手为python magic methods准备一些更简明并且有详细案例的文档. 我开始每周整理一篇博客, 到现在为止我已经全部完成了, 整理成了这篇指导.
我希望你能喜欢, 把它当做一篇教程 复习资料或者参考, 我仅仅希望他能作为一篇人性化的python magic methods指导.</description></item><item><title>sql备忘</title><link>https://zhw.in/post/sql%E5%A4%87%E5%BF%98/</link><pubDate>Mon, 20 May 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/sql%E5%A4%87%E5%BF%98/</guid><description>mysql初始化密码 /etc/init.d/mysql stop # mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp;amp; # mysql -u root mysql mysql&amp;gt; UPDATE user SET Password=PASSWORD('newpassword') where USER='root'; mysql&amp;gt; FLUSH PRIVILEGES; mysql&amp;gt; quit # /etc/init.d/mysql restart # mysql -uroot -p Enter password: &amp;lt;输入新设的密码newpassword&amp;gt; ###获取最后n个字段
建临时表带自动增1的id字段
select top 5 * from temp_table order by id desc</description></item><item><title>sublime text 2 备忘</title><link>https://zhw.in/post/sublime-text-2-%E5%A4%87%E5%BF%98/</link><pubDate>Mon, 25 Mar 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/sublime-text-2-%E5%A4%87%E5%BF%98/</guid><description>安装包管理 Ctrl + ` import urllib2,os; pf=&amp;lsquo;Package Control.sublime-package&amp;rsquo;; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),&amp;lsquo;wb&amp;rsquo;).write(urllib2.urlopen(&amp;lsquo;http://sublime.wbond.net/'+pf.replace(' &amp;lsquo;,'%20&amp;rsquo;)).read()); print &amp;lsquo;Please restart Sublime Text to finish installation&amp;rsquo; 回车
快捷键 安装插件,以Alignment为例
Shift + Ctrl + p install alignment 代码补齐
Shift + Ctrl + a zencoding Ctrl + Alt + Enter div#page&amp;gt;div.logo+ul#navigation&amp;gt;li*5&amp;gt;a &amp;lt;div id=&amp;quot;page&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;logo&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;ul id=&amp;quot;navigation&amp;quot;&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; vim模式 Shift + Ctrl + P 输入settings user 调出Preferences：Settings - User 打开Preferences.</description></item><item><title>寒假记录</title><link>https://zhw.in/post/%E5%AF%92%E5%81%87%E8%AE%B0%E5%BD%95/</link><pubDate>Wed, 30 Jan 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/%E5%AF%92%E5%81%87%E8%AE%B0%E5%BD%95/</guid><description>学习使用socket模块 2013-01-30 创建tcp服务器 客户端时,遇到如下错误,由于不能上网,无法查询特此记录
Traceback (most recent call last): File &amp;ldquo;tsTserv.py&amp;rdquo;, line 21, in data = tcpSerSock.recv(BUFSIZ) File &amp;ldquo;/usr/lib/python2.7/socket.py&amp;rdquo;, line 170, in _dummy raise error(EBADF, &amp;lsquo;Bad file descriptor&amp;rsquo;) socket.error: [Errno 9] Bad file descriptor</description></item><item><title>vagrant 备忘</title><link>https://zhw.in/post/vagrant-%E5%A4%87%E5%BF%98/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://zhw.in/post/vagrant-%E5%A4%87%E5%BF%98/</guid><description>安装 gem install vagrant Vagrant Official Boxes https://github.com/mitchellh/vagrant/wiki/Available-Vagrant-Boxes
使用 第一次使用,进入工作目录 vagrant box add lucid32 http://files.vagrantup.com/lucid32.box #初始化虚拟机 vagrant init lucid32 #启动虚拟机 vagrant up #ssh进入 vagrant ssh #关闭虚拟机 vagrant halt #打包虚拟机 vagrant package --output base-ubuntu-rvm.box 配置文件 Vagrantfile 端口转发
#将虚拟机80端口转发到宿主机8080端口 config.vm.forward_port 80, 8080</description></item><item><title>thankpad E420 ubuntu 双显卡配置</title><link>https://zhw.in/post/thankpad-e420-ubuntu-%E5%8F%8C%E6%98%BE%E5%8D%A1%E9%85%8D%E7%BD%AE/</link><pubDate>Thu, 13 Dec 2012 00:00:00 +0000</pubDate><guid>https://zhw.in/post/thankpad-e420-ubuntu-%E5%8F%8C%E6%98%BE%E5%8D%A1%E9%85%8D%E7%BD%AE/</guid><description>&lt;p>###首先卸载曾经的显卡驱动
sudo apt-get remove &amp;ndash;purge fglrx fglrx-amdcccle fglrx-dev&lt;br>
###安装闭源前准备的库
sudo apt-get install build-essential cdbs fakeroot dh-make debhelper debconf libstdc++6 dkms libqtgui4 wget execstack libelfg0 dh-modaliases linux-headers-generic&lt;/p>
&lt;p>###如果是64位ubuntu,安装32位库:
sudo apt-get install ia32-libs&lt;/p>
&lt;p>###然后下载最新催化剂驱动&lt;br>
wget &lt;a href="http://www2.ati.com/drivers/linux/amd-driver-installer-catalyst-12.10-x86.x86_64.zip">http://www2.ati.com/drivers/linux/amd-driver-installer-catalyst-12.10-x86.x86_64.zip&lt;/a>&lt;br>
unzip amd-driver-installer-catalyst-12.10-x86.x86_64.zip&lt;br>
chmod +x amd-driver-installer-catalyst-12.10-x86.x86_64.run&lt;/p></description></item><item><title>11月月度总结</title><link>https://zhw.in/post/11%E6%9C%88%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 03 Dec 2012 00:00:00 +0000</pubDate><guid>https://zhw.in/post/11%E6%9C%88%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93/</guid><description>&lt;p>###总结
刚刚看了&lt;a class="link" href="http://www.cnblogs.com/fuyunbiyi" target="_blank" rel="noopener"
>浮云比翼&lt;/a>同学的博客,感觉每月总结一些还是很必要的,每次想写博客的时候总是怕麻烦,然后就不了了之了,想这样给自己一个强制性的要求,每个月多多少少写一些,等回过头来看时,不会是一片空白.&lt;br>
最近这个月真的干了不少事,因为有项目压在手里的缘故吧,一直很忙,现在在做一个汽配商城的网站,后台功能已经差不多了,下周左右就可以着手写前台了,不过对前端真的不怎么感冒,现在是打算找一个类似的站点直接copy吧,罪过罪过&amp;hellip;&lt;br>
很多学长都说过做项目时学到的东西最多也最快,现在真的体会到了,后台使用python写的,django框架,以前也看过好久文档和django book 当写起来时还是发现没什么思路,行胜于言,要铭记于心,不能光靠嘴上说的,一定要即使练习,快速记忆.&lt;/p></description></item><item><title>vim备忘</title><link>https://zhw.in/post/vim%E5%A4%87%E5%BF%98/</link><pubDate>Sun, 25 Nov 2012 00:00:00 +0000</pubDate><guid>https://zhw.in/post/vim%E5%A4%87%E5%BF%98/</guid><description>注释 用&amp;quot;#&amp;ldquo;注释当前行
:s/^/# 在2~50行首添加&amp;rdquo;#&amp;ldquo;注释
:2,50s/^ /# 用&amp;rdquo;#&amp;ldquo;注释当前行和当前行后面的三行
:.,+3s/^/# 用&amp;rdquo;#&amp;ldquo;注释所有行
:%s/^/# 补全 英文单词补全
set dictionary+=/usr/share/dict/words CTRL-X_CTRL-K 包含路径及文件名
CTRL-X_CTRL-F 曾经输入过的变量名或字符串
CTRL-N 行补全 CTRL-X_CTRL-L 万能补全 filetype plugin on CTRL-X_CTRL-O
vim 256色问题 自从转战kde后一直忍受konsole中难看的vim主题, 也找了好多对策,比如使用gvim..转战sublime等等, 但终究是不方便. 今天才知道是konsole默认不支持256色的问题,在~/.vimrc中添加了下面两句后解决了 &amp;ldquo;解决konsole 256 色显示问题
let g:solarized_termcolors=256 set t_Co=256</description></item><item><title>ubuntu12.10 配置记录</title><link>https://zhw.in/post/ubuntu12.10-%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 23 Nov 2012 00:00:00 +0000</pubDate><guid>https://zhw.in/post/ubuntu12.10-%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</guid><description>&lt;p>很久没更新的ubuntu12.04更新了下，结果直接挂掉了。。。
前几天装上了新出的12.10，gnome还是老样子，效果有一丢丢改进.
为了以后安装方便，很多环境的配置方法记录下。&lt;/p>
&lt;p>为了使用pyCharm，要用sun jdk，openjdk明显不给力。。。&lt;/p>
&lt;p>sunjdk文件可以在&lt;a class="link" href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7u9-downloads-1859576.html" target="_blank" rel="noopener"
>oracle&lt;/a>，已经保存到百度网盘。&lt;/p>
&lt;pre>&lt;code>chmod +x jdk-6u32-linux-x64.bin
sudo ./jdk-6u32-linux-x64.bin
sudo mv jdk1.6.0_32 /usr/lib/jvm/
#配置环境变量，这是更改后的
PATH=&amp;quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/local/jvm/jdk1.6.0_34/bin&amp;quot;
CLASSPATH=&amp;quot;/usr/lib/jvm/jdk1.6.0_34/lib&amp;quot;
JAVA_HOME=&amp;quot;/usr/lib/jvm/jdk1.6.0_34&amp;quot;
&lt;/code>&lt;/pre></description></item><item><title>my nook color</title><link>https://zhw.in/post/my-nook-color/</link><pubDate>Sat, 10 Nov 2012 00:00:00 +0000</pubDate><guid>https://zhw.in/post/my-nook-color/</guid><description>&lt;p>##入手&lt;/p>
&lt;hr>
&lt;p>前几天入手的nook color，新刷的cm7系统，主要是为了看书购入的，感觉还不错，ips屏还是比较给力的。&lt;br>
&lt;img src="http://pic.yupoo.com/waqei_v/Cpdaqzbo/14tRpy.jpg" alt="正面" />&lt;/p></description></item><item><title>first blog</title><link>https://zhw.in/post/first-blog/</link><pubDate>Thu, 25 Oct 2012 00:00:00 +0000</pubDate><guid>https://zhw.in/post/first-blog/</guid><description> 经过各种纠结，jekyll博客终于建成了，如你所见.</description></item><item><title>mysql 编码相关</title><link>https://zhw.in/post/mysql-%E7%BC%96%E7%A0%81%E7%9B%B8%E5%85%B3/</link><pubDate>Thu, 25 Oct 2012 00:00:00 +0000</pubDate><guid>https://zhw.in/post/mysql-%E7%BC%96%E7%A0%81%E7%9B%B8%E5%85%B3/</guid><description>配置文件 my.cnf 默认字符集为 utf-8 default-character-set = utf-8 character-set-server= utf-8 mysql 命令 mysql设置编码命令 SET character_set_client = utf8; SET character_set_connection = utf8; SET character_set_database = utf8; SET character_set_results = utf8;/*这里要注意很有用*/ SET character_set_server = utf8; SET collation_connection = utf8_bin; SET collation_database = utf8_bin; SET collation_server = utf8_bin; #查看数据库编码 show variables like 'characte%'; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ #创建数据库时指定编码 #GBK: create database test2 DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci; #UTF8: CREATE DATABASE `test2` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci #数据库连接串中指定字符集 URL=jdbc:mysql://yourIP/college?</description></item></channel></rss>