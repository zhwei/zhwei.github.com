<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="问题来源 gotit一直正常运行，现在不是成绩查询的时间了，访问量也少了不少。趁着这段时间打算重构下网站代码，当初上线之后总是添加功能或者应对正方教务系统，现在的代码非常乱。还有就是，正方查询的页面加载很慢，主要是登录之前的pre_login操作， 需要先访问一次正方教务系统，获取初始化用户状态(此处保存的是一个对象, 下面称其为zf)和中文验证码图片。
相对其他页面的响应来说， 这段时间是最长的， 粗略测试了下，其时间在0.6～1.5秒之间不等，多次刷新的时候需要等待的时间更长，并且有的时候正方系统会响应不及时，导致无法获取用户状态。
开始时，我打算将zf缓存到redis中，每一时刻都缓存若干个zf供用户使用，设置好过期时间，删除过期的zf，如果缓存的zf小于一定数目则进行获取，如此供用户使用，此时用户每次进行GET的时候仅从服务器本机获取数据而不用访问正方系统，一定会快很多。后来发现，并不是所有的对象都是能序列化(pickle)的。在《python标准库》中提到：
 套接字、文件句柄、数据库链接以及其他运行时状态依然依赖操作系统或者其他进程的对象可能无法用一种有意义的方式保存。
 需要缓存的zf对象就不能进行序列化，因为他依赖urllib2提供的opener，这样就不能使用redis进行缓存，只能将其缓存在内存中，比如保存在一个全局字典中，现在模拟登录的方法就是使用了一个字典保存用户get时获得的zf，用户post信息（学号、密码和验证码）后从字典中将zf读取出来，继续处理。
多线程加速 开始 全部操作需要四个线程：   DaemonThread(D) : 守护线程
 检测缓存字典中zf的数目 如果小于某一特定数值时则创建缓存（即创建zf） 如果大于该数目则等待    CreateThread(CR) : 创建缓存进程
 守护线程的子线程 缓存不足的时候守护线程调用该线程创建缓存    CheckThread(CH) : 过期处理
 检查缓存字典中的键值对是否过期 过期则POP    MainThread(M) : 调用上述线程
 多线程调用    all_clients: 缓存没有使用过的zf
 保存缓存的字典 结构： time_md5 -&amp;gt; (zf, viewstate, timeStart )    used_clients: 经过get操作的zf
 用户进行get操作时，使用的键将从前者中pop到这个字典中，供后来的POST操作时模拟登录使用 结构： time_md5 -&amp;gt; (zf, viewstate, timeStart )    login_succeed: 登录成功的zf"><title>Gotit多线程加速及缓存</title><link rel=canonical href=https://zhw.in/post/gotit%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%80%9F%E5%8F%8A%E7%BC%93%E5%AD%98/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="Gotit多线程加速及缓存"><meta property="og:description" content="问题来源 gotit一直正常运行，现在不是成绩查询的时间了，访问量也少了不少。趁着这段时间打算重构下网站代码，当初上线之后总是添加功能或者应对正方教务系统，现在的代码非常乱。还有就是，正方查询的页面加载很慢，主要是登录之前的pre_login操作， 需要先访问一次正方教务系统，获取初始化用户状态(此处保存的是一个对象, 下面称其为zf)和中文验证码图片。
相对其他页面的响应来说， 这段时间是最长的， 粗略测试了下，其时间在0.6～1.5秒之间不等，多次刷新的时候需要等待的时间更长，并且有的时候正方系统会响应不及时，导致无法获取用户状态。
开始时，我打算将zf缓存到redis中，每一时刻都缓存若干个zf供用户使用，设置好过期时间，删除过期的zf，如果缓存的zf小于一定数目则进行获取，如此供用户使用，此时用户每次进行GET的时候仅从服务器本机获取数据而不用访问正方系统，一定会快很多。后来发现，并不是所有的对象都是能序列化(pickle)的。在《python标准库》中提到：
 套接字、文件句柄、数据库链接以及其他运行时状态依然依赖操作系统或者其他进程的对象可能无法用一种有意义的方式保存。
 需要缓存的zf对象就不能进行序列化，因为他依赖urllib2提供的opener，这样就不能使用redis进行缓存，只能将其缓存在内存中，比如保存在一个全局字典中，现在模拟登录的方法就是使用了一个字典保存用户get时获得的zf，用户post信息（学号、密码和验证码）后从字典中将zf读取出来，继续处理。
多线程加速 开始 全部操作需要四个线程：   DaemonThread(D) : 守护线程
 检测缓存字典中zf的数目 如果小于某一特定数值时则创建缓存（即创建zf） 如果大于该数目则等待    CreateThread(CR) : 创建缓存进程
 守护线程的子线程 缓存不足的时候守护线程调用该线程创建缓存    CheckThread(CH) : 过期处理
 检查缓存字典中的键值对是否过期 过期则POP    MainThread(M) : 调用上述线程
 多线程调用    all_clients: 缓存没有使用过的zf
 保存缓存的字典 结构： time_md5 -&amp;gt; (zf, viewstate, timeStart )    used_clients: 经过get操作的zf
 用户进行get操作时，使用的键将从前者中pop到这个字典中，供后来的POST操作时模拟登录使用 结构： time_md5 -&amp;gt; (zf, viewstate, timeStart )    login_succeed: 登录成功的zf"><meta property="og:url" content="https://zhw.in/post/gotit%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%80%9F%E5%8F%8A%E7%BC%93%E5%AD%98/"><meta property="og:site_name" content="zhwei's Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="Gotit"><meta property="article:published_time" content="2013-09-13T00:00:00+00:00"><meta property="article:modified_time" content="2013-09-13T00:00:00+00:00"><meta name=twitter:site content="zhwei_"><meta name=twitter:title content="Gotit多线程加速及缓存"><meta name=twitter:description content="问题来源 gotit一直正常运行，现在不是成绩查询的时间了，访问量也少了不少。趁着这段时间打算重构下网站代码，当初上线之后总是添加功能或者应对正方教务系统，现在的代码非常乱。还有就是，正方查询的页面加载很慢，主要是登录之前的pre_login操作， 需要先访问一次正方教务系统，获取初始化用户状态(此处保存的是一个对象, 下面称其为zf)和中文验证码图片。
相对其他页面的响应来说， 这段时间是最长的， 粗略测试了下，其时间在0.6～1.5秒之间不等，多次刷新的时候需要等待的时间更长，并且有的时候正方系统会响应不及时，导致无法获取用户状态。
开始时，我打算将zf缓存到redis中，每一时刻都缓存若干个zf供用户使用，设置好过期时间，删除过期的zf，如果缓存的zf小于一定数目则进行获取，如此供用户使用，此时用户每次进行GET的时候仅从服务器本机获取数据而不用访问正方系统，一定会快很多。后来发现，并不是所有的对象都是能序列化(pickle)的。在《python标准库》中提到：
 套接字、文件句柄、数据库链接以及其他运行时状态依然依赖操作系统或者其他进程的对象可能无法用一种有意义的方式保存。
 需要缓存的zf对象就不能进行序列化，因为他依赖urllib2提供的opener，这样就不能使用redis进行缓存，只能将其缓存在内存中，比如保存在一个全局字典中，现在模拟登录的方法就是使用了一个字典保存用户get时获得的zf，用户post信息（学号、密码和验证码）后从字典中将zf读取出来，继续处理。
多线程加速 开始 全部操作需要四个线程：   DaemonThread(D) : 守护线程
 检测缓存字典中zf的数目 如果小于某一特定数值时则创建缓存（即创建zf） 如果大于该数目则等待    CreateThread(CR) : 创建缓存进程
 守护线程的子线程 缓存不足的时候守护线程调用该线程创建缓存    CheckThread(CH) : 过期处理
 检查缓存字典中的键值对是否过期 过期则POP    MainThread(M) : 调用上述线程
 多线程调用    all_clients: 缓存没有使用过的zf
 保存缓存的字典 结构： time_md5 -&amp;gt; (zf, viewstate, timeStart )    used_clients: 经过get操作的zf
 用户进行get操作时，使用的键将从前者中pop到这个字典中，供后来的POST操作时模拟登录使用 结构： time_md5 -&amp;gt; (zf, viewstate, timeStart )    login_succeed: 登录成功的zf"><link rel="shortcut icon" href=/images/favicon.ico></head><body><script>(function(){const colorSchemeKey='StackColorScheme';if(!localStorage.getItem(colorSchemeKey)){localStorage.setItem(colorSchemeKey,"auto");}})();</script><script>(function(){const colorSchemeKey='StackColorScheme';const colorSchemeItem=localStorage.getItem(colorSchemeKey);const supportDarkMode=window.matchMedia('(prefers-color-scheme: dark)').matches===true;if(colorSchemeItem=='dark'||colorSchemeItem==='auto'&&supportDarkMode){document.body.dataset.scheme='dark';}else{document.body.dataset.scheme='light';}})();</script><div class="container main-container flex on-phone--column extended article-page with-toolbar"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=/img/avatar_hua214120a4d200677a7520b2605f86182_99547_300x0_resize_box_2.png width=300 height=282 class=site-logo loading=lazy alt=Avatar>
<span class=emoji>🏠</span></figure><h1 class=site-name><a href=https://zhw.in>zhwei's Blog</a></h1><h2 class=site-description>Be Your Personal Best</h2></header><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/about><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=/archives><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><li><a href=https://github.com/zhwei><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0c-2.4-1.6-3.5-1.3-3.5-1.3a4.2 4.2.0 00-.1 3.2 4.6 4.6.0 00-1.3 3.2c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg><span>GitHub</span></a></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></ol></aside><main class="main full-width"><div id=article-toolbar><a href=https://zhw.in class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><article class=main-article><header class=article-header><div class=article-details><h2 class=article-title><a href=/post/gotit%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%80%9F%E5%8F%8A%E7%BC%93%E5%AD%98/>Gotit多线程加速及缓存</a></h2><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>2013-09-13</time></footer></div></header><section class=article-content><h1 id=问题来源>问题来源</h1><p>gotit一直正常运行，现在不是成绩查询的时间了，访问量也少了不少。趁着这段时间打算重构下网站代码，当初上线之后总是添加功能或者应对正方教务系统，现在的代码非常乱。还有就是，正方查询的页面加载很慢，主要是登录之前的<code>pre_login</code>操作， 需要先访问一次正方教务系统，获取初始化用户状态(此处保存的是一个对象, 下面称其为zf)和中文验证码图片。</p><p>相对其他页面的响应来说， 这段时间是最长的， 粗略测试了下，其时间在0.6～1.5秒之间不等，多次刷新的时候需要等待的时间更长，并且有的时候正方系统会响应不及时，导致无法获取用户状态。</p><p>开始时，我打算将zf缓存到redis中，每一时刻都缓存若干个zf供用户使用，设置好过期时间，删除过期的zf，如果缓存的zf小于一定数目则进行获取，如此供用户使用，此时用户每次进行GET的时候仅从服务器本机获取数据而不用访问正方系统，一定会快很多。后来发现，并不是所有的对象都是能序列化(pickle)的。在《python标准库》中提到：</p><blockquote><p>套接字、文件句柄、数据库链接以及其他运行时状态依然依赖操作系统或者其他进程的对象可能无法用一种有意义的方式保存。</p></blockquote><p>需要缓存的zf对象就不能进行序列化，因为他依赖urllib2提供的opener，这样就不能使用redis进行缓存，只能将其缓存在内存中，比如保存在一个全局字典中，现在模拟登录的方法就是使用了一个字典保存用户get时获得的zf，用户post信息（学号、密码和验证码）后从字典中将zf读取出来，继续处理。</p><h1 id=多线程加速>多线程加速</h1><h2 id=开始>开始</h2><h4 id=全部操作需要四个线程>全部操作需要四个线程：</h4><ul><li><p><strong>DaemonThread</strong>(D) : 守护线程</p><ul><li>检测缓存字典中zf的数目</li><li>如果小于某一特定数值时则创建缓存（即创建zf）</li><li>如果大于该数目则等待</li></ul></li><li><p><strong>CreateThread</strong>(CR) : 创建缓存进程</p><ul><li>守护线程的子线程</li><li>缓存不足的时候守护线程调用该线程创建缓存</li></ul></li><li><p><strong>CheckThread</strong>(CH) : 过期处理</p><ul><li>检查缓存字典中的键值对是否过期</li><li>过期则POP</li></ul></li><li><p><strong>MainThread</strong>(M) : 调用上述线程</p><ul><li>多线程调用</li></ul></li><li><p><strong>all_clients</strong>: 缓存没有使用过的zf</p><ul><li>保存缓存的字典</li><li>结构： <strong>time_md5</strong> -> (zf, viewstate, timeStart )</li></ul></li><li><p><strong>used_clients</strong>: 经过get操作的zf</p><ul><li>用户进行get操作时，使用的键将从前者中pop到这个字典中，供后来的POST操作时模拟登录使用</li><li>结构： <strong>time_md5</strong> -> (zf, viewstate, timeStart )</li></ul></li><li><p><strong>login_succeed</strong>: 登录成功的zf</p><ul><li>供用户二次查询时使用</li><li>结构： <strong>time_md5</strong> -> (zf, xh, timeStart )</li></ul></li><li><p><strong>temp_clients</strong>: 创建缓存时的中转字典</p><ul><li>现将生成的zf放到这里，生成一定数量的时候，与<code>all_clients</code>合并，避免<code>all_clients</code>长期加锁。</li></ul></li></ul><h4 id=相关变量>相关变量</h4><blockquote><p>viewstate : 正方教务系统post时需要的一个参数，类似csrf<br>timeStart : 键值对的每一次操作都会将该值更新为当前时间<br>xh : 查询者的学号, 供二次查询时其他查询使用</p></blockquote><h2 id=多线程相关>多线程相关</h2><p>所有的线程都将<code>setDaemon(True)</code>, 保证主线程结束后其他线程也相应结束。</p><p>这里使用了<code>threading</code>提供的<code>Condition</code>对象，condition提供了对复杂线程的同步问题的一个解决方案， 也叫做条件变量，除了提供加锁、需求（acquire）和释放（release）方法外，还提供了停止等待（wait）和事件通知（notify）方法。</p><p>在这里可以先判断字典的键值对数目，小于定值的时候D则创建若干个CR线程创建缓存, 每个CR线程创建一个zf即停止。如果大于定值则等待(不过这里不能时候<code>wait</code>，应为wait会一直阻塞，直到被notify), 这里让其继续判断。</p><p>还有一个要说的是，python里字典和元组都是线程安全的，因为python对这两种数据结构的操作都是在字节码层次。</p><h2 id=具体方法>具体方法</h2><p>网站程序启动时调用M， M调用D & CH, D一直监控<strong>all_clients</strong>键值对的数目， CH每隔定值（与正方系统的验证码过期时间有关）检查一遍前三个字典中所有键的创建时间，大于定值则POP。</p><p>对字典中的键值对进行过期检查的时候，现将整个字典copy一下，对copy的字典进行检测，将过期的键输出到列表中，统一pop，避免长期加锁，这也算浪费空间节约时间的一种方法吧。</p><p>每个键的创建时间在每一次进行操作的时候都会变更为当前时间，就像正常上网时，每个一段时间刷新一次网页那登录就永远不会过期。</p><h1 id=未完>(未完)</h1></section><footer class=article-footer><section class=article-tags><a href=/tags/gotit/>Gotit</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper></aside><footer class=site-footer><section class=copyright>&copy;
2012 -
2021 zhwei's Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=2.0.1>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const customFont=document.createElement('link');customFont.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";customFont.type="text/css";customFont.rel="stylesheet";document.head.appendChild(customFont);}());</script></body></html>